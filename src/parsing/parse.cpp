/*
 * phc -- the open source PHP compiler
 * See doc/license/README.license for licensing information
 *
 * Parser wrapper. 
 */

#include <fstream>
#include "config.h"
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include "parse.h"
#include "cmdline.h"
#include "php_parser.tab.hpp"
#include "parsing/XML_parser.h"
#include "parsing/PHP_context.h"
#include "process_ast/Invocation_targets.h"
#include "process_ast/Variable_targets.h"
#include "process_ast/Remove_parser_temporaries.h"
#include "process_ast/Remove_concat_null.h"
#include "process_ast/Token_conversion.h"
#include "process_ast/Process_includes.h"

extern struct gengetopt_args_info args_info;

String* search_file(String* filename, List<String*>* dirs);
void run_standard_transforms(AST_php_script* php_script);

AST_php_script* parse(String* filename, List<String*>* dirs, bool is_ast_xml)
{
	assert(filename);
	
	AST_php_script* php_script = NULL;

	String* full_path = search_file(filename, dirs);

	if(full_path == NULL)
		return NULL;

	if(is_ast_xml)
	{
		#ifdef HAVE_XERCES
		if(*full_path == "-")
			php_script = parse_ast_xml_stdin();
		else
			php_script = parse_ast_xml_file(full_path);
		#else
			phc_error(ERR_NO_XML_SUPPORT, NULL, 0);
		#endif
	}
	else
	{
		FILE* input = NULL;

		if(*full_path == "-")
		{
			input = stdin;
		}
		else
		{
			input = fopen(full_path->c_str(), "r");
			if(!input) return NULL;
		}
	
		assert(input);
		
		// Compile
		PHP_context* context = new PHP_context(input, full_path);

		if(args_info.dump_tokens_flag)
		{
			// run the lexer only
			// TODO: reenable
			// while(parser.php_lexer->yylex());
		}
		else
		{
			if(!PHP_parse(context))
			{
				php_script = context->php_script;
				run_standard_transforms(php_script);
			}
		}
	
		if(input != stdin) fclose(input);
	}
	
	return php_script;
}

String* search_file(String* filename, List<String*>* dirs)
{
	struct stat buf;

	if(*filename == "-")
		return filename;
	
	if(dirs == NULL)
		return filename;

	// Check whether filename can be opened without searching dirs
	if(!stat(filename->c_str(), &buf))
	{
		return filename;
	}

	// Otherwise, search dirs
	List<String*>::const_iterator i;
	for(i = dirs->begin(); i != dirs->end(); i++)
	{
		String full_path = **i;
		full_path.append("/");
		full_path.append(*filename);
	
		if(!stat(full_path.c_str(), &buf))
		{
			return new String(full_path);
		}
	}

	// Otherwise, search dirs (with backslashes instead of forward slashes)
	for(i = dirs->begin(); i != dirs->end(); i++)
	{
		String full_path = **i;
		full_path.append("/");
		full_path.append(*filename);

		String::iterator j;
		for(j = full_path.begin(); j != full_path.end(); j++)
			if(*j == '/') *j = '\\';

		if(!stat(full_path.c_str(), &buf))
		{
			return new String(full_path);
		}
	}
	
	// If file could not be found, return NULL
	return NULL;
}

void run_standard_transforms(AST_php_script* php_script)
{
	// Implicit method targets are left NULL by the parser, since it does not
	// know whether a call to a function f() should be call to %MAIN%::f or
	// %STDLIB%::f. Invocation_targets fixes this. Should be called very early
	// on, because until it is called, the tree is in an inconsistent state.
	Invocation_targets it;
	php_script->visit(&it);	

	// Similar to method targets, implicit variable targets must be set to
	// %MAIN% if the variable is a global variable. It does not matter much
	// when this transform is called.
	Variable_targets vt;
	php_script->visit(&vt);

	// Remove temporaries generated by the parser for the purpose
	// of building the AST. It doesn't really matter when this 
	// transform runs, as long as it runs before XML serialisation
	Remove_parser_temporaries rpt;
	php_script->visit(&rpt);

	// The parser will introduce concatenations with "" in certain
	// (frequent) circumstances. This will remove them. This could
	// probably be run at any time.
	Remove_concat_null rcn;
	php_script->transform(&rcn);

	// There are a number of strange rules based on the value of an
	// integer/real, which must be applied. The parser cannot do this,
	// since we have to determine whether there are 1 or more - signs
	// before the number, and this is unknown at compile time. This
	// should be run early.
	Token_conversion tc;
	php_script->transform(&tc);

	// This replaces include() statements with the file they include,
	// based on certain rules. Since the included script will be
	// pre-parsed, process_includes should be one of the last transforms
	// to run, else the effort will be duplicated (which could lead to
	// an error)
	if(args_info.compile_time_includes_flag)
	{
		Process_includes pi;
		php_script->transform(&pi);
	}
}
