{-
 - phc -- the open source PHP compiler
 - See doc/license/README.license for licensing information
 -
 - Definition of the HIR
 -
 - Note that the HIR does not support the 'declare' statement, which nobody
 - uses or can even define precisely. It does not even seem to be supported
 - by the interpreter.
 -}

{-
	Configuration
-}

prefix "HIR";
external class "Object";
use list "List";
use string "String";
use namespace "HIR";

{-
   Top-level structure	
-}

php_script ::= statement* ;

statement ::=
     class_def | interface_def | method 
	  | return | static_declaration | global
	  | try | throw | eval_expr
	  | label | goto | branch ;
--	| assign_var | assign_var_var | assign_array | push_array

{-
	Class and method definitions
-}

class_def ::= 
   class_mod CLASS_NAME extends:CLASS_NAME? implements:INTERFACE_NAME* member* ;
class_mod ::= "abstract"? "final"? ;

interface_def ::= INTERFACE_NAME extends:INTERFACE_NAME* member* ;

member ::= method | attribute ;

method ::= signature statement*? ;
signature ::= method_mod is_ref:"&"? METHOD_NAME formal_parameter* ;
method_mod ::= "public"? "protected"? "private"? "static"? "abstract"? "final"? ;
formal_parameter ::= type is_ref:"&"? var:name_with_default ;
-- formal_parameter ::= type is_ref:"&"? VARIABLE_NAME static_value? ;
type ::= CLASS_NAME? ;

attribute ::= attr_mod var:name_with_default ;
-- attribute ::= attr_mod VARIABLE_NAME static_value? ;
attr_mod ::= "public"? "protected"? "private"? "static"? "const"?  ;

name_with_default ::= VARIABLE_NAME expr? ;

{-
   Statements
-}

return ::= expr? ;
-- return ::= VARIABLE_NAME? ;

static_declaration ::= var:name_with_default ;
-- static_declaration ::= VARIABLE_NAME static_value? ;
global ::= variable_name ;
-- variable_name ::= VARIABLE_NAME | variable_variable;

try ::= statement* catches:catch* ;
catch ::= CLASS_NAME VARIABLE_NAME statement* ;
throw ::= expr ;
-- throw ::= VARIABLE_NAME ;

eval_expr ::= expr ;

{-
   HIR constructs (without a PHP equivalent)
-}

branch ::= expr iftrue:LABEL_NAME iffalse:LABEL_NAME;
goto ::= LABEL_NAME ;
label ::= LABEL_NAME ;

-- assign_var     ::= lhs:VARIABLE_NAME is_ref:"&"? ignore_errors:"@"? rhs:expr ;
-- assign_array   ::= lhs:VARIABLE_NAME index:VARIABLE_NAME is_ref:"&"? rhs:VARIABLE_NAME ;
-- assign_var_var ::= lhs:VARIABLE_NAME                     is_ref:"&"? rhs:VARIABLE_NAME ;
-- push_array     ::= lhs:VARIABLE_NAME                     is_ref:"&"? rhs:VARIABLE_NAME ; 


{-
   Expressions
-}

expr ::=
     assignment 
   | cast | unary_op | bin_op 
   | constant | instanceof
   | variable | pre_op | array
--   | variable_name | index_array
   | method_invocation | new 
	| literal ;
	
literal ::= INT<long> | REAL<double> | STRING<String*> | BOOL<bool> | NULL<> ;
   
assignment ::= variable is_ref:"&"? expr ;
-- index_array       ::= VARIABLE_NAME index:VARIABLE_NAME ;
-- variable_variable ::= VARIABLE_NAME ; 


cast     ::= CAST VARIABLE_NAME ;
unary_op ::= OP VARIABLE_NAME ;
bin_op   ::= left:VARIABLE_NAME OP right:VARIABLE_NAME ; 


constant ::= CLASS_NAME? CONSTANT_NAME ;

instanceof ::= VARIABLE_NAME class_name ;

variable ::= target? variable_name array_indices:VARIABLE_NAME?* ;
variable_name ::= VARIABLE_NAME | reflection ;
reflection ::= VARIABLE_NAME ;

target ::= expr | CLASS_NAME ;
-- target ::= VARIABLE_NAME | CLASS_NAME;

pre_op ::= OP variable ;

array ::= array_elem* ;
array_elem ::= key:expr? is_ref:"&"? val:expr ;

method_invocation ::= target? method_name actual_parameter* ;
method_name ::= METHOD_NAME | reflection ;

-- actual_parameter ::= is_ref:"&"? expr ;
actual_parameter ::= is_ref:"&"? target? VARIABLE_NAME array_indices:VARIABLE_NAME?* ;

new ::= class_name actual_parameter* ;
class_name ::= CLASS_NAME | reflection ;

-- static_value ::= literal | static_array | constant ;
 
-- static_array      ::= static_array_elem* ;
-- static_array_elem ::= static_array_key? is_ref:"&"? val:static_value ;
-- static_array_key  ::= literal | constant ; 


{-
 - Additional structure 
 -}

identifier ::=
	  INTERFACE_NAME | CLASS_NAME | METHOD_NAME | VARIABLE_NAME 
	| CAST | OP | CONSTANT_NAME | LABEL_NAME
	;  

{-
 - Extra attributes and methods (mixin code)
 -}

#include <iostream>
#include <sstream>
#include <iomanip>
#include "lib/error.h"
#include "lib/Object.h"
#include "lib/List.h"
#include "lib/String.h"
#include "lib/Boolean.h"
#include "lib/Integer.h"
#include "lib/AttrMap.h"

class HIR_node : Object 
{
public:
	AttrMap* attrs;

	// Return the line number of the node (or 0 if unknown)
	int get_line_number()
	{
		Integer* i = dynamic_cast<Integer*>(attrs->get("phc.line_number"));
		if(i != NULL)
			return i->value();
		else
			return 0;
	}

	// Return the filename of the node (or NULL if unknown)
	String* get_filename()
	{
		return dynamic_cast<String*>(attrs->get("phc.filename"));
	}

	HIR_node()
	{
		// Constructor gets called because all classes inherit from
		// HIR_node virtually; also, because maketea knows HIR_node is
		// abstract, it won't add a constructor itself
		attrs = new AttrMap();
	}

	void clone_mixin_from(HIR_node* in)
	{
		attrs = in->attrs->clone();
	}

	void assert_mixin_valid()
	{
		assert(attrs != NULL);

		AttrMap::const_iterator i;
		for(i = attrs->begin(); i != attrs->end(); i++)
		{
			if ((*i).first != "phc.line_number"
				&& (*i).first != "phc.filename")
			{
				assert((*i).second != NULL);
			}
		}
	}

	bool is_mixin_equal(HIR_node* in)
	{
		// Compare line number and filename
		// (We can't compare the entire attrs map because Object cannot
		// necessarily be compared for equality)

		if(get_line_number() != in->get_line_number())
			return false;

		if(get_filename() == NULL)
		{
			if(in->get_filename() != NULL)
				return false;
		}
		else
		{
			if(*get_filename() != *in->get_filename())
				return false;
		}

		return true;
	}

	// Return the comments associated with the node
	List<String*>* get_comments()
	{
		List<String*>* comments = dynamic_cast<List<String*>*>(attrs->get("phc.comments"));
		return comments;
	}
};

class HIR_signature 
{
public:
	HIR_signature(const char* name) 
	{
		this->method_mod = HIR_method_mod::new_PUBLIC();
		this->is_ref = false;
		this->method_name = new Token_method_name(new String(name));
		this->formal_parameters = new List<HIR_formal_parameter*>;
	}
};

class HIR_method_mod 
{
public:
	HIR_method_mod()
	{
		is_public = false;
		is_protected = false;
		is_private = false;
		is_static = false;
		is_abstract = false;
		is_final = false;
	}

	HIR_method_mod(HIR_method_mod* a, HIR_method_mod* b) 
	{
		this->is_public 		= a->is_public		|| b->is_public;
		this->is_protected	= a->is_protected	|| b->is_protected;
		this->is_private		= a->is_private	|| b->is_private;
		this->is_static		= a->is_static		|| b->is_static;
		this->is_abstract		= a->is_abstract	|| b->is_abstract;
		this->is_final			= a->is_final		|| b->is_final;
	}

	static HIR_method_mod* new_PUBLIC() 
	{
		return new HIR_method_mod(true, false, false, false, false, false);		
	}

	static HIR_method_mod* new_PROTECTED() 
	{ 
		return new HIR_method_mod(false, true, false, false, false, false);		
	}

	static HIR_method_mod* new_PRIVATE() 
	{ 
		return new HIR_method_mod(false, false, true, false, false, false);		
	}

	static HIR_method_mod* new_STATIC() 
	{ 
		return new HIR_method_mod(false, false, false, true, false, false);		
	}

	static HIR_method_mod* new_ABSTRACT() 
	{ 
		return new HIR_method_mod(false, false, false, false, true, false);		
	}

	static HIR_method_mod* new_FINAL() 
	{ 
		return new HIR_method_mod(false, false, false, false, false, true);		
	}
};

class HIR_class_def
{
public:
	HIR_class_def(HIR_class_mod* mod) 
	{
		this->class_mod = mod;
		this->class_name = NULL;
		this->extends = NULL;
		this->implements = new List<Token_interface_name*>;
		this->members = new List<HIR_member*>;
	}

	HIR_class_def(const char* name)
	{
		this->class_mod = new HIR_class_mod(false, false);
		this->class_name = new Token_class_name(new String(name));
		this->extends = NULL;
		this->implements = new List<Token_interface_name*>;
		this->members = new List<HIR_member*>;
	}

	void add_member(HIR_member* member) 
	{
		this->members->push_back(member);
	}

	// Returns NULL if the method could not be found
	HIR_method* get_method(const char* name)
	{
		List<HIR_member*>::const_iterator i;
		for(i = members->begin(); i != members->end(); i++)
		{
			HIR_method* method = dynamic_cast<HIR_method*>(*i);
			if(method && *method->signature->method_name->value == name)
				return method;
		}

		return NULL;
	}
};

class HIR_eval_expr
{
public:
	void _init()
	{
		assert (expr != NULL);
	}
};

class HIR_variable
{
public:
	HIR_variable(HIR_variable_name* name) 
	{
		this->target = NULL;
		this->variable_name = name;
		this->array_indices = new List<Token_variable_name*>;
	}
};

class HIR_method_invocation
{
public:
	HIR_method_invocation(const char* name, HIR_actual_parameter* arg) 
	{ 
		this->target = NULL;
		this->method_name = new Token_method_name(new String(name));
		this->actual_parameters = new List<HIR_actual_parameter*> (arg);
	}

	HIR_method_invocation(Token_method_name* name, HIR_actual_parameter* arg) 
	{ 
		this->target = NULL;
		this->method_name = name; 
		this->actual_parameters = new List<HIR_actual_parameter*> (arg);
	}
};

class HIR_formal_parameter
{
public:
	HIR_formal_parameter(HIR_type* type, Token_variable_name* name) 
	{
		this->type = type;
		this->is_ref = false;
		this->var = new HIR_name_with_default(name, NULL);
	}

	HIR_formal_parameter(HIR_type* type, bool is_ref, Token_variable_name* name) 
	{ 
		this->type = type;
		this->is_ref = is_ref;
		this->var = new HIR_name_with_default(name, NULL);
	}
};

class HIR_attr_mod
{
public:
	HIR_attr_mod()
	{
		is_public = false;
		is_protected = false;
		is_private = false;
		is_static = false;
		is_const = false;
	}

	HIR_attr_mod(HIR_method_mod* mm) 
	{
		if(mm->is_final)
			phc_error("The final modifier is only allowed for methods", mm->get_filename(), mm->get_line_number());

		this->is_public = mm->is_public;
		this->is_protected = mm->is_protected;
		this->is_private = mm->is_private;
		this->is_static = mm->is_static;
		this->is_const = false;
	}

	static HIR_attr_mod* new_PUBLIC() 
	{
		return new HIR_attr_mod(true, false, false, false, false);
	}

	static HIR_attr_mod* new_PROTECTED() 
	{ 
		return new HIR_attr_mod(false, true, false, false, false);
	}

	static HIR_attr_mod* new_PRIVATE() 
	{
		return new HIR_attr_mod(false, false, true, false, false);
	}

	static HIR_attr_mod* new_STATIC() 
	{
		return new HIR_attr_mod(false, false, false, true, false);
	}
	
	static HIR_attr_mod* new_CONST() 
	{
		return new HIR_attr_mod(false, false, false, false, true);
	}
};

class HIR_bin_op
{
public:
	HIR_bin_op(Token_variable_name* left, Token_variable_name* right, const char* op) 
	{
		this->left = left;
		this->op = new Token_op(new String(op));
		this->right = right;
	}
};

class HIR_pre_op
{
public:
	HIR_pre_op(HIR_variable* var, const char* op) 
	{
		this->variable = var;
		this->op = new Token_op(new String(op));
	}
};

class HIR_unary_op
{
public:
	HIR_unary_op(Token_variable_name* variable_name, const char* op) 
	{
		this->variable_name = variable_name;
		this->op = new Token_op(new String(op));
	}
};

class HIR_cast
{
public:
	HIR_cast(const char* cast, Token_variable_name* variable_name) 
	{
		this->cast = new Token_cast(new String(cast));
		this->variable_name = variable_name;
	}
};

class HIR_identifier
{
public:
	virtual String* get_value_as_string() = 0;
};

class HIR_literal
{
public:
	virtual String* get_value_as_string() = 0;
	virtual String* get_source_rep() = 0;
};

class Token_int
{
private:

	// Constructors can't call virtual functions, so we create a non-virtual to
	// do the work. This is then called by the virtual function, and is also
	// safely called from the constructor.
	String* _get_value_as_string()
	{
		std::ostringstream os;
		os << value;
		return new String(os.str());
	}

public:
	virtual String* get_value_as_string()
	{
		return _get_value_as_string ();
	}

	Token_int (int v)
	{
		value = v;
		source_rep = _get_value_as_string ();
	}
};

class Token_real
{
private:

	// See comment in Token_int::_get_value_as_string ()
	String* _get_value_as_string()
	{
		std::ostringstream os;
		// setprecision(20) outputs as many digits as required, with
		// a maximum of 20
		os << setprecision(20) << value;
		// unfortunately, that means that if no digits are required at
		// all (after the decimal point), the decimal point is left out
		// completely; setting the "showpoint" flag fixes this, but then
		// the STL _always_ shows all 20 digits, which is not what we 
		// want either. Hence, we insert the ".0" manually if necessary:
		string str = os.str();
		if(str.find('.') >= str.size())
			str.append(".0");

		return new String(str);
	}

public:
	virtual String* get_value_as_string()
	{
		return _get_value_as_string ();
	}

	Token_real (double v)
	{
		value = v;
		source_rep = _get_value_as_string ();
	}
};

class Token_bool
{
private:
	// See comment in Token_int::_get_value_as_string ()
	String* _get_value_as_string()
	{
		if(value)
			return new String("True");
		else
			return new String("False");
	}

public:
	virtual String* get_value_as_string()
	{
		return _get_value_as_string ();
	}

	Token_bool (bool v)
	{
		value = v;
		source_rep = _get_value_as_string ();
	}
};

class Token_string
{
public:
	virtual String* get_value_as_string()
	{
		return value;
	}

	bool is_value_valid()
	{
		return value != NULL;
	}

	String* clone_value()
	{
		return value->clone();
	}

	Token_string (String* v)
	{
		value = v;
		source_rep = v;
	}
};

class Token_null
{
public:
	virtual String* get_value_as_string()
	{
		return new String("NULL");
	}
	Token_null ()
	{
		source_rep = new String ("NULL");
	}
};
