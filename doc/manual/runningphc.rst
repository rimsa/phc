<chapter id="runningphc">
<title id="runningphc.title">Running |phc|</title>

<para> Once you have installed |phc| (see <xref linkend="install"
endterm="install.title">), run it by typing </para>

.. sourcecode::

phc --help

		
<para>
	You should see
</para>

.. sourcecode::

phc 0.2.0

Usage: phc [OPTIONS]... [FILES]...

  -h, --help               Print help and exit
      --full-help          Print help, including hidden options, and exit
  -V, --version            Print version and exit

GENERAL OPTIONS:
  -v, --verbose            Verbose output  (default=off)
  -c, --compile            Compile  (default=off)
      --pretty-print       Pretty print input according to the Zend style 
                             guidelines  (default=off)
      --obfuscate          Obfuscate input  (default=off)
      --run=STRING         Run the specified plugin (may be specified multiple 
                             times)
      --r-option=STRING    Pass option to a plugin (specify multiple flags in 
                             the same order as multiple plugins - 1 option only 
                             per plugin)
  -d, --define=STRING      Define ini entry (only affects -c and --include)

INPUT OPTIONS:
      --read-xml=passname  Assume the input is in XML format. Start processing 
                             after the named pass
      --include            Parse included or required files at compile-time  
                             (default=off)

COMPILATION OPTIONS:
  -C, --c-option=STRING    Pass option to the C compile (e.g., -C-g; can be 
                             specified multiple times)
      --extension=NAME     Generate a PHP extension called NAME instead of a 
                             standalone application
  -O, --optimize=STRING    Optimize  (default=`0')
  -o, --output=FILE        Place executable into file FILE
  -e, --execute            Run executable after compiling (implies -c)  
                             (default=off)

PRETTY PRINTING OPTIONS:
      --next-line-curlies  Output the opening curly on the next line instead of 
                             on the same line  (default=off)
      --no-leading-tab     Don't start every line in between <?php .. ?> with a 
                             tab  (default=off)
      --tab=STRING         String to use for tabs while unparsing  
                             (default=`	')
      --no-hash-bang       Do not output any #! lines  (default=off)


<para>
	Now write a very small PHP script, for example
</para>

<programlisting>
<? <reserved>echo</reserved> "Hello world!"; ?>
</programlisting>

<para>
	and save it to <filename>helloworld.php</filename>. Then
	run |phc|:
</para>

.. sourcecode::

phc --pretty-print helloworld.php


<para>
	This should output a pretty-printed version of your PHP
	script back to standard output:
</para>
			
<programlisting>
<?<reserved>php</reserved>
   <reserved>echo</reserved> "Hello world!";
?>
</programlisting>

<para>
	You can see a list of options controlling the style of pretty printing, using the
	``--full-help`` option.
</para>

<!-- TODO:
	what can phc do:
		XML
		print canonical form
		run plugins
		combine files
		obfuscate
		warnings
-->
<section>
<title>Compiling executables</title>

<para>
	|phc| can compile either executables or extensions. To compile an executable,
	|phc| creates C code, which it compiles and links to the PHP embed SAPI.
	Since it links to PHP, you have access to all of PHP's large built-in
	standard library. In order to compile the "hello world" executable from
	before, run
</para>

.. sourcecode::

phc -c helloworld.php -o helloworld


<para>
	This creates an executable ``helloworld``, which can then be run
</para>

.. sourcecode::

./helloworld


<para>
	If you prefer to run your executable immediately after it compiles, use the
	``-e``. |phc| will compile your program, then immediately execute
	it. You can also view the C code generated by |phc|:
</para>

.. sourcecode::

phc --generate-c helloworld.php > helloworld.c


<para>
	One of the advantages of |phc| is that it can optimize your program. Using
	the ``-O`` flag, you can instruct |phc| to analyse your source code,
	and perform simple optimizations. On simple benchmarks, this can increase
	the speed of your application by 50%. To optimize:
</para>

.. sourcecode::

phc -O2 -c helloworld.php -o helloworld


<para>
	|phc| generates C code, which is then compiled by ``gcc``. To see
	the command passed to ``gcc`` by |phc|, use the ``-v``
	flag.
</para>

<para>
	If you
	specify the ``-O`` flag, |phc| will also pass the ``-O``
	flag to ``gcc``, which will optimize your code further. The
	argument to the ``-O`` flag must therefore be usable by
	``gcc``, so it must be any of ``-O0`` (default),
	``-O1``, ``-O2``, ``-O3`` or ``-Os``.
	Consult the <ulink
	url="http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options">gcc
	manual</ulink> for more details.
</para>

<para>
	It is also possible to pass command-line arguments to ``gcc``
	through |phc|, using the ``-C`` flag. For example, to disable
	inlining of the generated code by ``gcc``, using
	``-fno-inline``:
</para>

.. sourcecode::

phc -c -O2 helloworld.php -o helloworld -C-fno-inline



</section>

<section>
<title>Compiling web applications</title>

<warning>
<para>
	In order to compile web applications, it is currently necessary to alter
	your <filename>php.ini</filename> file, or have access to the root account.
	We welcome suggetions of a different method which avoids these requirements,
	especially if they would work in a shared hosting environment.
</para>
</warning>


<warning>
<para>
	This section is experimental. Please <ulink
	url="http://www.phpcompiler.org/mailinglist.html">report any
	problems</ulink>.
</para>
</warning>

<para>
	We have created the command-line option ``--web-app``, which will
	in the future automate the process of compiling a web application.
	Unfortunately, for now, please follow these steps.
</para>
	
<para>
	We describe how to create and install an extension using the C code
	generated by |phc|. While we give an overview of creating extensions,
	significantly more detail can be found in the <ulink
	url="http://devzone.zend.com/node/view/id/1021">Zend Extension Writing
	Tutorial</ulink> and in <ulink
	url="http://www.amazon.com/dp/067232704X">Extending and Embedding
	PHP</ulink>.
</para>

<para>
	To begin, create a new directory for the extension. We'll use
	<filename>ext/</filename> in our example. Generate C code from
	<filename>helloworld.php</filename> using |phc|.
</para>

.. sourcecode::

phc --generate-c helloworld.php > ext/helloworld.c


<para>
	Create a new file, <filename>ext/config.m4</filename>, by copying the
	following, and changing instances of "helloworld" appropriately:
</para>

.. sourcecode::

PHP_ARG_ENABLE(helloworld, whether to enable Hello World support,
[ --enable-helloworld   Enable Hello World support])

if test "$PHP_HELLOWORLD" = "yes"; then
  AC_DEFINE(HAVE_HELLOWORLD, 1, [Whether you have Hello World])
  PHP_NEW_EXTENSION(helloworld, helloworld.c, $ext_shared)
fi


<para>
	In the previous section, we described using the PHP embed SAPI. If you
	installed a copy of PHP with ``--enable-embed`` enabled, it is
	important <emphasis>NOT</emphasis> to use that version for the following
	commands.  Instead, you should the same version as your webserver uses. From
	the ext/ directory, run:
</para>

.. sourcecode::

phpize --with-php-config=/usr/bin/php-config
./configure --enable-helloworld


<para>
	Build and install the extension (if you dont have root, refer instead to
	<xref linkend=alternate.method endterm=alternate.method.title>):
</para>

.. sourcecode::

make
sudo make install


<para>
	In your web folder, replace the existing <filename>helloworld.php</filename> file contents with the following:
</para>

<programlisting>
<?php
	<reserved>dl</reserved> ("helloworld.so");
	__MAIN__ ();
?>
</programlisting>

<para>
	If the ``dl()`` function is not enabled in your <filename>php.ini</filename> file, enable it:
</para>

.. sourcecode::

enable_dl = On;


<para>
	Accessing <filename>helloworld.php</filename> should now work. 
</para>



<section id=alternate.method>
<title id=alternate.method.title>Alternatives</title>

<para>
	Instead of setting ``enable_dl``, you can instead load the
	extension manually in your <filename>php.ini</filename> file:
</para>

.. sourcecode::

extension=helloworld


<para>
	You can also avoid installing the extension using ``sudo make
	install`` by adding an alternate extension directory:
</para>

.. sourcecode::

extensions_dir="/full/path/to/ext"


	
</section>
</section>

<section id="xml">

<title id="xml.title">Writing and Reading XML</title>

<para>
	|phc| can output an XML representation of the PHP script. You can use this
	representation if you want to process PHP scripts using tools in your
	desired framework, instead of using |phc| plugins. After processing the XML
	representation, |phc| can convert it back into PHP. To generate an XML
	version of a PHP script, run
</para>

.. sourcecode::

./phc --dump-xml=ast helloworld.php > helloworld.xml


<para>
	When reading the XML back in, all the usual features of
	|phc| are again available; in particular, it is possible to read an XML file,
	and write PHP syntax. To convert the XML file we just generated back to PHP
	syntax, run
</para>

.. sourcecode::

./phc --read-xml=ast --pretty-print helloworld.xml


<para>
	The generated XML should use the schema <ulink
	url="http://www.phpcompiler.org/phc-1.0">http://www.phpcompiler.org/phc-1.0</ulink>.
	However, our XML schema is currently broken.
</para>

</section>
<section>
<title>Internal Representations</title>
<para>
	After parsing, |phc| converts a PHP script into an Abstract Syntax Tree
	(AST) (this is further explained in <xref linkend="treetutorial1">). This is
	very useful for processing PHP scripts which you wish to convert back into
	PHP. However, for some tasks, especially program analysis, a simpler form of
	the PHP script is more suitable. |phc| offers two other Internal
	Representations (IRs). The High-level Internal Representation (HIR)
	simplifies most expressions by assigning them to temporary variables.
	However, code represented in the HIR is still valid PHP. The Medium-level
	Internal Representation (MIR) converts HIR statements to simpler components,
	for example converting control-flow statements like the
	``for``-loop, into ``goto``s. To view PHP in any of these
	forms, use the ``--dump`` option:
</para>

.. sourcecode::

phc --dump=ast helloworld.php
phc --dump=hir helloworld.php
phc --dump=mir helloworld.php


<para>
	Nearly all |phc| options work as well on the HIR and MIR as on the AST. For example, XML can be read and written:
</para>

.. sourcecode::

phc --dump-xml=hir | ./myprog | phc --read-xml=hir


</section>

<section>

<title>Graphical Output</title>

<para>
	If you have a DOT viewer installed on your system (for example, <ulink
	url="http://www.graphviz.org">graphviz</ulink>), you can view the AST
	graphically. First, ask |phc| to output the AST in DOT format:
</para>

.. sourcecode::

./phc --dump-dot=ast helloworld.php > helloworld.dot


<para> You can then view the tree (<filename>helloworld.dot</filename>) using
Graphviz. In most Unix/Linux systems, you should be able to do </para>

.. sourcecode::

dotty helloworld.dot


<para> And you should see the tree; it should look similar to the tree shown in
figure <xref linkend="helloworldtree">. </para>

<figure id="helloworldtree">
<title>Abstract syntax tree for &ldquo;Hello world&rdquo;</title>
<mediaobject>
<imageobject>
<imagedata fileref="img/helloworld.jpg">
</imageobject>
</mediaobject>
</figure>

</section>
<section>

<title>Including files</title>

<para>
	|phc| has initial support for compile-time processing of PHP's
	``include`` built-in.  Enabling this feature inserts the included
	statements in the AST in the place of the ``include`` statement.
	Included functions, classes and interfaces become part of the file's
	top-level scope.  In the event that |phc| is not able to process the
	``include`` statement (for example, if the file cannot be found), a
	warning is issued, and the ``include`` statement is left in place.
	To enable this support, run
</para>

.. sourcecode::

./phc --include script_with_includes.php


<para> The include support is intended to mimic <ulink
url="http://php.net/manual/en/function.include.php">PHP's include
built-in</ulink>, as far as can be achieved at compile time. |phc| supports:
</para>

<itemizedlist>
	<listitem><para>
		Moving included statements to the point at which ``include`` was
		called. Naturally, these statement's use the variable scope at the point
		at which they are included,
	</para></listitem>

	<listitem><para>
		Preserving ``__FILE__`` and ``__LINE__`` statements,
	</para></listitem>

	<listitem><para>
		Moving included functions to the ``%MAIN%`` class, and importing
		the included classes,
	</para></listitem>

	<listitem><para>
		``include``, and ``require``. If the specified file
		cannot be found, parsed, or if the argument to ``include`` is
		not a string literal, the include statement is left in
		place.
	</para></listitem>
</itemizedlist>

<para> |phc| does not support: </para>

<itemizedlist>
	<listitem><para>
		Return values in included scripts. We intend to support these in the
		future. They will likely be supported in a later stage of the compilation
		process, instead of in the AST,
	</para></listitem>

	<listitem><para>
		Calling ``include`` on anything other than a literal string
		containing the filename of a local file. This excludes variables and
		remote files. These may be supported when more static analyses are
		available,
	</para></listitem>

	<listitem><para>
		``include_once`` and ``require_once``, as we cannot
		guarantee that the file to be included is not included elsewhere.  These
		statements will not be processed, and combinations of
		``include`` or ``require`` and
		``include_once`` or ``require_once`` may cause
		incorrect behaviour with this option set,
	</para></listitem>

	<listitem><para>
		Updating ``get_included_files()`` to reflect the included
		files.
	</para></listitem>
</itemizedlist>

</section>
</chapter>
