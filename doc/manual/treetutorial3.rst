Restructuring the Tree
======================


Now that we have seen in <xref linkend="treetutorial1"> how we can traverse the
tree, and in <xref linkend="treetutorial2"> how we can modify individual nodes
in the tree, in this tutorial we will look at modifying the structure of the
tree itself.

The transform that we will be considering in this tutorial is one that is used
in |phc| itself. The transform is called :class:`Remove_concat_null` and can be
found in :file:`src/process_ast/Remove_concat_null.h`. The purpose of the
transform is to remove string concatenation with the empty string. For example, 
</para>

.. sourcecode:: php

   <?php
      $s = "foo" . "";
   ?>


is translated to 

.. sourcecode:: php

   <?php
      $s = "foo";
   ?>


The reason that this transform is implemented in |phc| is due to how the |phc|
parser deals with in-string syntax. For example, if you write 

.. sourcecode:: php

   $a = "foo $b bar";


the corresponding tree generated by |phc| is 

.. sourcecode:: php

   $a = "foo " . $b . " bar";


In other words, the variables are pulled out of the string, and the various
components are then concatenated together. However, taken to its logical
conclusion, that means that if you write

.. sourcecode:: php

   $a = "foo $b";


the parser generates 

.. sourcecode:: php

   $a = "foo " . $b . "";


Obviously, the second concatenation is unnecessary, and the
:class:`Remove_concat_null` transform cleans this up. In this tutorial we will
explain how this transform can be written. 

Introducing the :class:`Tree_transform` API
===========================================

Concatenation is a binary operator, so we are interested in nodes of type
:class:`Bin_op`. If you check the grammar, or, alternatively,
:file:`src/generated/AST.h`, you will find that :class:`Bin_op`` has three
attributes: a :attr:`left` and a :attr:`right` expression (of type
:class:`Expr`) and the operator itself (:attr:`op` of type :class:`OP`). Thus,
we are interested in nodes of type :class:`Bin_op` whose :attr:`op` equals the
single dot (for string concatenation). 

Based on the previous two tutorials, we might try something like this:

.. sourcecode:: c++

   class Remove_concat_null : public Visitor
   {
   public:
      void pre_bin_op(Bin_op* in)
      {
         // Find concat operators
         if (*in->op->value == ".")
         {
            // ...
         }
      }
   }


The problem is, what are we going to do inside the ``if``? Tree visitors can
only inspect and modify ``*in``; they cannot restructure the tree. In
particular, we cannot replace ``*in`` by a new node. For this purpose, |phc|
offers a separate API, the tree **transformation** API. It looks very similar
to the tree visitor API, but there are two important differences. First, the
``pre`` and ``post`` methods can modify the structure of the tree by returning
new nodes. Second, there are no "generic" methods in the tree transform API.
So, it is not possible to define a transformation that would replace all
statements by something else. (It is not clear how that would be useful,
anyway.) 

So, we need to write our transformation using the :class:`Tree_transform` API,
defined in :file:`AST_transform.h`. Restructuring the class above yields

.. sourcecode:: c++

   class Remove_concat_null : public Transform
   {
   public:
      Expr* pre_bin_op(Bin_op* in)
      {
         // Find concat operators
         if(*in->op->value == ".")
         {
            // ...
         }
      }
   }

			
The differences between the previous version have been highlighted. We inherit
from a different class, and :func:`pre_bin_op` now has a return value, which is the
node that will replace ``*in``. If you check the default implementation of
:func:`pre_bin_op` in :file:`AST_transform.cpp`, you'll find: 

.. sourcecode:: c++

   Expr* Transform::pre_bin_op(Bin_op* in)
   {
      return in;
   }

			
The ``return in;`` is very important; as we mentioned before, the return value
of :func:`pre_bin_op` will replace ``*in`` in the tree. Therefore, if we don't
want to replace ``*in``, or perhaps if we want to replace ``*in`` only if a
particular condition holds, we must return ``in``. This will replace ``*in`` by
``in`` itself. 

The second thing to note is that the return type of :func:`pre_bin_op` is
:class:`Expr` instead of :class:`Bin_op`. This means that we can replace a
binary operator node by another other expression node. The <xref
linkend="maketeatheory" endterm="maketeatheory.title"> explains exactly how the
signatures for the ``pre`` and ``post`` methods are derived, but in most cases
they are what you'd expect.  The easiest way to check is to simply look them up
in :file:`<AST_transform.h>`. 

The Implementation
==================

We wanted to get rid of useless concatenation operators. To be precise, if the
binary operator is the concatenation operator, and the left operand is the
empty string, we want to replace the node by the right operand; similarly, if
the right operand is the empty string, we want to replace the operator by its
left operand. Here's the full transform: 
	
.. sourcecode:: c++

class Remove_concat_null : public Transform
{
public:
   Expr* post_bin_op(Bin_op* in)
   {
      STRING* empty = new STRING(new String(""));
      Wildcard<Expr>* wildcard = new Wildcard<Expr>;
   
      <emphasis>// Replace with right operand if left operand is the empty string</emphasis>
      if(in->match(new Bin_op(empty, wildcard, ".")))
         return wildcard->value;
   
      <emphasis>// Replace with left operand if right operand is the empty string</emphasis>
      if(in->match(new Bin_op(wildcard, empty, ".")))
         return wildcard->value;
      
      return in;
   }
}


<para>
	We already explained what ``match`` does in <xref
	linkend="treetutorial2">, but we have not yet explained the use of
	wildcards. If you are using a wildcard (``WILDCARD``) in a pattern
	passed to ``match``, ``match`` will not take that subtree
	into account. Thus, 
</para> 
	
.. sourcecode::

if(in->match(new Bin_op(empty, WILDCARD, ".")))

			
<para>
	can be paraphrased as "is ``in`` a binary operator with the
	empty string as the left operand and ``"."`` as the operator (I
	don't care about the right operand)?" If the match succeeded, you can
	find out which expression was matched by the wildcard by accessing
	``wildcard->value``. 
</para>

</section>
<section>

<title> Running Transformations </title>

<para>
	Recall from the previous two tutorials that visitors are run with a call to
	``visit``: 
</para>

.. sourcecode::

extern "C" void run_ast (PHP_script* in, Pass_manager* pm, String* option)
{
    SomeVisitor visitor;
    in->visit(&amp;visitor);
}


<para> Likewise, transformations are run with a call to 
``transform_children``: </para>

.. sourcecode::

extern "C" void run_ast (PHP_script* in, Pass_manager* pm, String* option)
{
    SomeTransform transform;
    in->transform_children(&amp;transform);
}


<para>
	We invoke ``transform_children`` because we should not replace the
	top-level node in the AST (the ``PHP_script`` node itself).
</para> 

</section>
<section>

<title> A Subtlety </title>

<para>
	If you don't understand this section right now, don't worry about it; you
	might find it useful to read it again after having gained some experience
	with the transformation API. 
</para>

<para>
	We have implemented the transform as a <emphasis>post-</emphasis>transform
	rather than a <emphasis>pre-</emphasis> transform. Why? Suppose we
	implemented the transform as a pre-transform.  Consider the following PHP
	expression (bracketed explicitly for emphasis:) 
</para>

.. sourcecode::

("" . $a) . ""


<para>
	The first binary operator we encounter is the second one (get |phc| to print
	the tree if you don't see why.) So, we apply the transform and replace the
	operator by its left operand, which happens to be ``("" . $a)``.
	We then continue <emphasis>and transform the children of the that
	node</emphasis>, because that is how the tree transform API is defined. But
	the <emphasis>children</emphasis> of that node are ``""`` and
	``$a``. So, that means that the other binary operator itself will
	never be processed! 
</para>

<para>
	There are two solutions to this problem. The first is the one we used above,
	and use a post-transform instead of a pre-transform. You should try to
	reason out why this works, but a rule of thumb is that unless there is a
	good reason to use a pre-transform, it's safer to use the post-transform,
	because in the post-transform the children of the node have already been
	transformed, so that you are looking at the "final" version of
	the node. 
</para>

<para>
	The second solution is to use a pre-transform, but explicitly tell |phc| to
	transform the new node in turn.  This is the less elegant solution, but
	sometimes this is the only solution that will work (see for example the
	``Token_conversion`` transform in the
	:file:`src/process_ast/Token_conversion.cpp`). To do this, you
	would replace 
</para>
         
.. sourcecode::

return in->right;


<para>
	by 
</para>

.. sourcecode::

return in->right->pre_transform(this);


</section>
<section>

<title> What's Next? </title>

<para>
	The next tutorial in this series, <xref linkend="treetutorial4"
	endterm="treetutorial4.title">, introduces a very important notion in
	transforms: the use of <emphasis>state</emphasis>. 
</para>

</section>
</chapter>
