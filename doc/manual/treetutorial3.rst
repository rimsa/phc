<chapter id="treetutorial3">
<title id="treetutorial3.title">Restructuring the Tree</title>

<section>
<title></title>

<para>
	Now that we have seen in <xref linkend="treetutorial1"> how we can traverse
	the tree, and in <xref linkend="treetutorial2"> how we can modify individual
	nodes in the tree, in this tutorial we will look at modifying the structure
	of the tree itself.
</para>	

<para>
	The transform that we will be considering in this tutorial is one that is
	used in &phc itself. The transform is called ``Remove_concat_null``
	and can be found in
	<filename>src/process_ast/Remove_concat_null.h</filename>. The purpose of
	the transform is to remove string concatenation with the empty string. For
	example, 
</para>

<programlisting>
&lt;?<reserved>php</reserved>
   $s = "foo" . "";
?&gt;
</programlisting>

<para>
	is translated to 
</para>

<programlisting>
&lt;?<reserved>php</reserved>
   $s = "foo";
?&gt;
</programlisting>

<para>
	The reason that this transform is implemented in &phc is due to how the &phc
	parser deals with in-string syntax. For example, if you write 
</para>

<programlisting>
$a = "foo $b bar";
</programlisting>

<para>
	the corresponding tree generated by &phc is 
</para>

<programlisting>
$a = "foo " . $b . " bar";
</programlisting>

<para> In other words, the variables are pulled out of the string, and the
various components are then concatenated together. However, taken to its
logical conclusion, that means that if you write </para>

<programlisting>
$a = "foo $b";
</programlisting>

<para>
	the parser generates 
</para>

<programlisting>
$a = "foo " . $b . "";
</programlisting>

<para>
	Obviously, the second concatenation is unnecessary, and the
	``Remove_concat_null`` transform cleans this up. In this tutorial
	we will explain how this transform can be written. 
</para>

</section>
<section>

<title> Introducing the ``Tree_transform`` API </title>

<para>
	Concatenation is a binary operator, so we are interested in nodes of type
	``Bin_op``. If you check the grammar, or, alternatively,
	<filename>src/generated/AST.h</filename>, you will find that
	``Bin_op`` has three attributes: a ``left`` and a
	``right`` expression (of type ``Expr``) and the operator
	itself (``OP* op``). Thus, we are interested in nodes of type
	``Bin_op`` whose ``op`` equals the single dot (for string
	concatenation). 
</para>

<para>
	Based on the previous two tutorials, we might try something like this:
</para>

<programlisting>
<reserved>class</reserved> Remove_concat_null : <reserved>public</reserved> Visitor
{
<reserved>public</reserved>:
   <reserved>void</reserved> pre_bin_op(Bin_op* in)
   {
      <emphasis>// Find concat operators</emphasis>
      <reserved>if</reserved>(*in-&gt;op-&gt;value == ".")
      {
         // ...
      }
   }
}
</programlisting>

<para>
	The problem is, what are we going to do inside the ``if``? Tree
	visitors can only inspect and modify ``*in``; they cannot
	restructure the tree. In particular, we cannot replace ``*in`` by a
	new node. For this purpose, &phc offers a separate API, the tree
	<emphasis>transformation</emphasis> API. It looks very similar to the tree
	visitor API, but there are two important differences. First, the
	``pre`` and ``post`` methods can modify the structure of
	the tree by returning new nodes. Second, there are no &ldquo;generic&rdquo;
	methods in the tree transform API. So, it is not possible to define a
	transformation that would replace all statements by something else. (It is
	not clear how that would be useful, anyway.) 
</para>

<para>
	So, we need to write our transformation using the
	``Tree_transform`` API, defined in
	<filename>AST_transform.h</filename>. Restructuring the class above yields
</para>

<programlisting>
<reserved>class</reserved> Remove_concat_null : <reserved>public</reserved> <boxed>Transform</boxed>
{
<reserved>public</reserved>:
   <boxed>Expr*</boxed> pre_bin_op(Bin_op* in)
   {
      <emphasis>// Find concat operators</emphasis>
      <reserved>if</reserved>(*in-&gt;op-&gt;value == ".")
      {
         // ...
      }
   }
}
</programlisting>
			
<para>
	The differences between the previous version have been highlighted. We
	inherit from a different class, and ``pre_bin_op`` now has a return
	value, which is the node that will replace ``*in``. If you check
	the default implementation of ``pre_bin_op`` in
	<filename>AST_transform.cpp</filename>, you'll find: 
</para>

<programlisting>
Expr* Transform::pre_bin_op(Bin_op* in)
{
   <reserved>return</reserved> in;
}
</programlisting>
			
<para>
	The ``return in;`` is very important; as we mentioned before, the
	return value of ``pre_bin_op`` will replace ``*in`` in the
	tree. Therefore, if we don't want to replace ``*in``, or perhaps if
	we want to replace ``*in`` only if a particular condition holds, we
	must return ``in``. This will replace ``*in`` by
	``in`` itself. 
</para>

<para>
	The second thing to note is that the return type of ``pre_bin_op``
	is ``Expr`` instead of ``Bin_op``. This means that we can
	replace a binary operator node by another other expression node. The <xref
	linkend="maketeatheory" endterm="maketeatheory.title"> explains exactly how
	the signatures for the ``pre`` and ``post`` methods are
	derived, but in most cases they are what you'd expect.  The easiest way to
	check is to simply look them up in
	<filename>&lt;AST_transform.h&gt;</filename>. 
</para> 

</section>
<section id="implementation">

<title>The Implementation</title> 

<para>
	We wanted to get rid of useless concatenation operators. To be precise, if
	the binary operator is the concatenation operator, and the left operand is
	the empty string, we want to replace the node by the right operand;
	similarly, if the right operand is the empty string, we want to replace the
	operator by its left operand. Here's the full transform: 
</para>
	
<programlisting>
<reserved>class</reserved> Remove_concat_null : <reserved>public</reserved> Transform
{
<reserved>public</reserved>:
   Expr* post_bin_op(Bin_op* in)
   {
      STRING* empty = <reserved>new</reserved> STRING(<reserved>new</reserved> String(""));
      Wildcard&lt;Expr&gt;* wildcard = <reserved>new</reserved> Wildcard&lt;Expr&gt;;
   
      <emphasis>// Replace with right operand if left operand is the empty string</emphasis>
      <reserved>if</reserved>(in-&gt;match(<reserved>new</reserved> Bin_op(empty, wildcard, ".")))
         <reserved>return</reserved> wildcard-&gt;value;
   
      <emphasis>// Replace with left operand if right operand is the empty string</emphasis>
      <reserved>if</reserved>(in-&gt;match(<reserved>new</reserved> Bin_op(wildcard, empty, ".")))
         <reserved>return</reserved> wildcard-&gt;value;
      
      <reserved>return</reserved> in;
   }
}
</programlisting>

<para>
	We already explained what ``match`` does in <xref
	linkend="treetutorial2">, but we have not yet explained the use of
	wildcards. If you are using a wildcard (``WILDCARD``) in a pattern
	passed to ``match``, ``match`` will not take that subtree
	into account. Thus, 
</para> 
	
<programlisting>
<reserved>if</reserved>(in-&gt;match(<reserved>new</reserved> Bin_op(empty, WILDCARD, ".")))
</programlisting>
			
<para>
	can be paraphrased as &ldquo;is ``in`` a binary operator with the
	empty string as the left operand and ``"."`` as the operator (I
	don't care about the right operand)?&ldquo; If the match succeeded, you can
	find out which expression was matched by the wildcard by accessing
	``wildcard->value``. 
</para>

</section>
<section>

<title> Running Transformations </title>

<para>
	Recall from the previous two tutorials that visitors are run with a call to
	``visit``: 
</para>

<programlisting>
<reserved>extern</reserved> "C" <reserved>void</reserved> run_ast (PHP_script* in, Pass_manager* pm, String* option)
{
    SomeVisitor visitor;
    in-&gt;visit(&amp;visitor);
}
</programlisting>

<para> Likewise, transformations are run with a call to 
``transform_children``: </para>

<programlisting>
<reserved>extern</reserved> "C" <reserved>void</reserved> run_ast (PHP_script* in, Pass_manager* pm, String* option)
{
    SomeTransform transform;
    in-&gt;transform_children(&amp;transform);
}
</programlisting>

<para>
	We invoke ``transform_children`` because we should not replace the
	top-level node in the AST (the ``PHP_script`` node itself).
</para> 

</section>
<section>

<title> A Subtlety </title>

<para>
	If you don't understand this section right now, don't worry about it; you
	might find it useful to read it again after having gained some experience
	with the transformation API. 
</para>

<para>
	We have implemented the transform as a <emphasis>post-</emphasis>transform
	rather than a <emphasis>pre-</emphasis> transform. Why? Suppose we
	implemented the transform as a pre-transform.  Consider the following PHP
	expression (bracketed explicitly for emphasis:) 
</para>

<programlisting>
("" . $a) . ""
</programlisting>

<para>
	The first binary operator we encounter is the second one (get &phc to print
	the tree if you don't see why.) So, we apply the transform and replace the
	operator by its left operand, which happens to be ``("" . $a)``.
	We then continue <emphasis>and transform the children of the that
	node</emphasis>, because that is how the tree transform API is defined. But
	the <emphasis>children</emphasis> of that node are ``""`` and
	``$a``. So, that means that the other binary operator itself will
	never be processed! 
</para>

<para>
	There are two solutions to this problem. The first is the one we used above,
	and use a post-transform instead of a pre-transform. You should try to
	reason out why this works, but a rule of thumb is that unless there is a
	good reason to use a pre-transform, it's safer to use the post-transform,
	because in the post-transform the children of the node have already been
	transformed, so that you are looking at the &ldquo;final&rdquo; version of
	the node. 
</para>

<para>
	The second solution is to use a pre-transform, but explicitly tell &phc; to
	transform the new node in turn.  This is the less elegant solution, but
	sometimes this is the only solution that will work (see for example the
	``Token_conversion`` transform in the
	<filename>src/process_ast/Token_conversion.cpp</filename>). To do this, you
	would replace 
</para>
         
<programlisting>
<reserved>return</reserved> in-&gt;right;
</programlisting>

<para>
	by 
</para>

<programlisting>
<reserved>return</reserved> in-&gt;right-&gt;pre_transform(this);
</programlisting>

</section>
<section>

<title> What's Next? </title>

<para>
	The next tutorial in this series, <xref linkend="treetutorial4"
	endterm="treetutorial4.title">, introduces a very important notion in
	transforms: the use of <emphasis>state</emphasis>. 
</para>

</section>
</chapter>
