Overview of the AST classes and transformation API
==================================================

This document explains the code for the AST classes, tree visitor API and tree
transformation API. All this code is generated by a tool called
:program:`maketea`. It does not explain how this code is derived from the |phc|
grammar; some of the details of this process are explained in <xref
linkend="maketeatheory" endterm="maketeatheory.title">.

The AST classes
---------------

There are two main kinds of AST classes: classes that correspond to
non-terminals in the grammar, and classes that correspond to terminals in the
grammar. Non-terminal classes contain an upper-case first letter.  Terminals,
or tokens, are entirely uppercase.  Examples are :class:`While`, :class:`Expr`,
:class:`METHOD_NAME` and :class:`INT`. 

The main difference is that token classes have one additional field (and
sometimes two). Every token class gets an attribute called :attr:`value`. The
type of this attribute depends on the token; for most tokens it is
:ctype:`String*` (this is the default); however, if the grammar explicitely
specifies a type for the value (in angular brackets, for example
``REAL<double>``), this overrides the default.

In addition, all the tokens classes have a method called
:func:`get_value_as_string()` and a method :func:`get_source_rep()`
when applicable. This is useful for programs that operate on general
:class:`Identifier` objects (such as :class:`METHOD_NAME` or
:class:`CLASS_NAME`) or :class:`Literal` (such as :class:`REAL` or
:class:`INT`). Note that the value returned by :func:`get_value_as_string()`
and :func:`get_source_rep()` may be different; for example,
:func:`get_source_rep()` might return ``0.5E-1``, while
:func:`get_value_as_string()` might return ``0.5``. 

All (non-terminal and terminal) then provide the following methods for deep
equality, pattern matching, cloning, calling a tree visitor and calling a tree
transformer. These methods are explained separately in sections below.



Deep Equality
-------------

Deep equality is implemented by :func:`bool deep_equals(Object* other)`. It
takes into account the entire tree structure generated by :program:`maketea`,
including any fields that are specified in the code in the grammar (see <xref
linkend="mixin">). Thus, :func:`deep_equals()` also compares line numbers, comments,
etc.  



Cloning
-------

Cloning is implemented by :func:`deep_clone()`. Cloning makes a (deep) copy of
a tree, so the set of all pointers in the new tree is completely distinct from
the set of pointers in the old tree. The only exception to this rule is that
cloning the :class:`WILDCARD` objects (see pattern matching, below) returns the
:class:`WILDCARD` object itself. 



Pattern Matching
----------------

Pattern matching is implemented by :func:`bool match(Object* pattern)`.
Pattern matching differs from deep equality in two ways.  First, it does not
take into account any fields added by the mixin code; for example, it does not
compare line numbers or comments.  

Second, :func:`match()` supports the use of wildcards.
	:program:`maketea` generates a special class called
	:class:`Wildcard`. You should never instantiate this class directly; in
	:file:`<AST.h>`, you will find the following
	declaration: 
</para> 

.. sourcecode::

extern Wildcard* WILDCARD;


<para>
	This ``WILDCARD`` is the sole instance of ``Wildcard``.
	When ``match`` encounters a reference to this object in a pattern,
	it does two things: it skips that field in the comparison (so it acts as a
	"don't care"), and it replaces the value of the field in the
	pattern by the value in the tree. For example, in the body of the
	``if`` in 
</para>

.. sourcecode::

CLASS_NAME* name = new CLASS_NAME(new String("SOME_CLASS"));
CLASS_NAME* pattern = new CLASS_NAME(WILDCARD);

if(name->match(pattern))
{
   <emphasis>// ...</emphasis>
}


<para>``pattern->value`` will be set to the corresponding value in
``name``. Tutorials <xref linkend="treetutorial3"
endterm="treetutorial3.title"> and <xref linkend="treetutorial4"
endterm="treetutorial4.title"> include examples of the use of wildcards. </para>

<para> Calling any methods on the ``WILDCARD`` object other than
``deep_clone`` will lead to a runtime error. </para>

</section>
<section>

<title> The Visitor API </title>

<figure id="seqdiagramvisitor">
<title>Sequence Diagram for the Visitor API</title>
<mediaobject>
<imageobject>
<imagedata fileref="img/visitor.jpg">
</imageobject>
</mediaobject>
</figure>

<para>
	Every AST class provides four methods to support the visitor API: ``void
	visit(AST::Visitor*)``, ``void pre_visit(AST::Visitor*)``,
	``void visit_children(AST::Visitor*)`` and ``void
	post_visit(AST::Visitor*)``. The implementation of each of these
	methods is very simple. 
</para>

<para>
	``visit`` simply calls ``pre_visit``,
	``visit_children`` and ``post_visit`` in order. It could
	have been implemented once and for all in the ``Node`` class (but
	is not, for no particular reason). 
</para>

<para>
	For a node ``x0``, which inherits from ``x1``, which
	inherits from ``x2``, which in turn inherits from ``x3``,
	etc., ``x0::pre_visit`` calls ``pre_x3``,
	``pre_x2``, ``pre_x1`` and ``pre_x0``, in that
	order, on the tree visitor object, passing itself as an argument.  If
	``x0`` inherits from multiple classes, all of the appropriate
	visitor methods will be invoked. However, if ``x0`` inherits from
	both ``x1a`` and ``x1b``, the programmer should not rely
	on the relative order of ``pre_x1a`` and ``pre_x1b``.
</para>

<para>
	``x0::visit_children`` simply calls
	``children_x0``.
</para>

<para>
	``x0::post_visit`` will call ``post_x0``,
	``post_x1``, etc. Again, if ``x0`` inherits from both
	``x1a`` and ``x1b``, the programmer should not rely on the
	relative order of ``post_x1a`` and ``post_x1b``. The only
	guarantee made by :program:`maketea` is that the order of
	the pre-methods will be the exact reverse of the order of the post-methods.
</para>

</section>
<section>

<title>The Transform API </title>

<figure id="seqdiagramtransform">
<title>Sequence Diagram for the Transform API</title>
<mediaobject>
<imageobject>
<imagedata fileref="img/transform.jpg">
</imageobject>
</mediaobject>
</figure>
<!-- TODO: error in the sequence diagram, AST_foo appears twice. I think the
first one should be AST_gen_foo? -->
<para>
	Every AST class ``AST_foo``, which inherits from
	``AST_gen_foo`` provides four methods to support the tree visitor
	API: ``AST_gen_foo* transform(AST::Transform*)``,
	``AST_gen_foo* pre_transform(AST::Transform*)``, ``void
	transform_children(AST::Transform*)`` and ``AST_gen_foo*
	post_transform(AST::Transform*)``. It is not entirely as
	straightforward as this; if ``AST_foo`` inherits from more than one
	class, the return type would probably be ``AST_foo``; in some
	cases, ``transform`` might return a ``AST_foo_list``
	instead. See the section <xref linkend="contextresolution"
	endterm="contextresolution.title"> in the grammar formalism for details;
	here we consider the programmer's perspective only. The exact signatures for
	a particular class can always be found in :file:`<AST.h>`.
	
</para>

<para>
	As with the visitor API, ``transform`` calls
	``pre_transform``, ``transform_children`` and
	``post_transform``. However, while ``transform`` calls
	``pre_transform`` on itself, it calls
	``transform_children`` and ``post_transform`` on the node
	returned by ``pre_transform``. If ``pre_transform``
	returns a vector, ``transform`` calls
	``transform_children`` and ``post_transform`` on every
	element in that vector, assembling all the results. 
</para>

<para>
	``pre_transform`` and ``post_transform`` simply call the
	appropriate method in the ``AST::Transform`` object.  However, if
	``pre_transform`` (or ``post_transform``) returns a list
	of nodes, the corresponding method in the tree transform object will expect
	two arguments: the node to be transformed, and an empty list of nodes that
	will be the return value of ``pre_transform``. In that case,
	``pre_transform`` will first create a new empty list, pass that in
	as the second argument to the corresponding method in the tree transform
	object, and then return that list. 
</para>

<para>
	``transform_children`` just calls the corresponding method in the
	tree transform object. 
</para>

</section>
</chapter>
