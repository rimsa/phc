<chapter id="treetutorial1">
<title id="treetutorial1.title">Traversing the Tree</title>

<section>

<title></title>

<para>
	In <xref linkend="gettingstarted">, we explained that &phc represents PHP
	scripts internally as an abstract syntax tree, and that the structure of
	this tree is determined by the <xref linkend="grammar"
	endterm="grammar.title">. We then showed how to make use of this tree to
	count the number of statements. However, the plugin we wrote only counted
	the &ldquo;top-level&rdquo; statements. Statements nested inside other
	statements (for example, statements inside the true or false branch of an
	<code>if</code> statement) were ignored. In this tutorial, we will rectify
	this problem and write a plugin that counts <emphasis>all</emphasis>
	statements in a script. So, for
</para>
		
<programlisting>
&lt;?<reserved>php</reserved>
   $x = 5;
   <reserved>if</reserved>($x == 5)
      <reserved>echo</reserved> "yes";
   <reserved>else</reserved>
      <reserved>echo</reserved> "no";
?&gt;
</programlisting>

<para>
	we should report four statements.
</para>

<para>
	Note that all the plugins that we will develop in these tutorials are
	included in the &phc distribution. For example, in this tutorial we will be
	developing two plugins: a difficult solution to the problem and an easy
	solution to the problem. You can run these plugins by running
</para>

<screen>
phc --run plugins/tutorials/count_statements_difficult.la test.php
</screen>
			
<para>
	or 
</para>

<screen>
phc --run plugins/tutorials/count_statements_easy.la test.php
</screen>

</section>

<section>

<title>The Grammar (Revisited)</title>

<para>
	How do we go about counting all statements in a script?  Remember that, as
	far as &phc is concerned, a PHP script consists of a number of statements,
	but some of those statements may have other statements nested inside them.
	Here is part of the &phc; grammar: 
</para>

<programlisting>
PHP_script ::= Statement* ;
Statement ::= Eval_expr | If | While | ...
If ::= Expr iftrue:Statement* iffalse:Statement* ;
While ::= Expr Statement* ;
</programlisting>

<para>
	The vertical bar (<code>|</code>) means &ldquo;or&rdquo;. So, a statement is
	either an evaluation of an expression (<code>eval_expr</code>), an
	<code>if</code> statement, or a <code>while</code> statement, or..  Thus,
	our running example is represented by the tree in <xref linkend="ifx5tree">.
	The four statements that we are interested in have been highlighted.
</para>

<figure id="ifx5tree">
<title>Abstract syntax tree for the running example</title>
<mediaobject>
<imageobject>
<imagedata fileref="img/ifx5.jpg">
</imageobject>
</mediaobject>
</figure>


</section>

<section>

<title>Statements and Expressions</title>

<para>
	The <code>Eval_expr</code> nodes in the tree probably need some explanation.
	There are many different types of statements in PHP:
	<code>if</code>-statements, <code>while</code>-statements,
	<code>for</code>-loops, etc. You can find the full list in the <xref
	linkend="grammar" endterm="grammar.title">. If you do look at the grammar,
	you will notice in particular that a function call is not actually a
	statement!  Instead, a function call is an <emphasis>expression</emphasis>.
</para> 

<para>
	The difference between statements and expressions is that a statement
	<emphasis>does</emphasis> something (for example, a <code>for</code>-loop
	repeats a bunch of other statements), but an expression has a
	<emphasis>value</emphasis>. For example, &ldquo;5&rdquo; is an expression
	(with value 5), &ldquo;1+1&rdquo; is an expression (with value 2), etc. A
	function call is also considered an expression. The value of a function call
is the value that the function returns. </para>

<para>
	Now, an <code>eval_expr</code> makes a statement from an expression.  So, if
	you want to use an expression where &phc; expects a statement, you have to
	use the grammar rule
</para>

<programlisting>
Statement ::= ... | Eval_expr ;
Eval_expr ::= Expr ;
</programlisting>

</section>

<section>

<title>The Difficult Solution</title>

<para>
	The following plugin is a partial solution to counting the number of
	statements in a tree. If you do not understand the code, do not worry! We
	will look at a much easier solution in a second. If you understand the
	comments, that is enough.
</para>
			
<programlisting>
<reserved>#include</reserved> &lt;AST.h&gt;
<reserved>#include</reserved> &lt;pass_manager/Plugin_pass.h&gt;

<reserved>int</reserved> count(AST::Statement_list* in)
{
   <emphasis>// Every item in "in" is a statement</emphasis>
   <reserved>int</reserved> num_statements = in->size();

   <emphasis>// But there can also be statements nested inside any</emphasis>
   <emphasis>// of the statements in "in". We consider each one in turn.</emphasis>
   AST_statement_list::const_iterator i;
   <reserved>for</reserved>(i = in->begin(); i != in->end(); i++)
   {
      <emphasis>// Check if the statement is an if-statement</emphasis>
      <reserved>if</reserved>(If* if_stmt = dynamic_cast&lt;If*&gt;(*i))
      {
         num_statements += count(if_stmt->iftrue);
         num_statements += count(if_stmt->iffalse);
      }
   }

   <reserved>return</reserved> num_statements;
}

<reserved>extern</reserved> "C" <reserved>void</reserved> load (Pass_manager* pm, Plugin_pass* pass)
{
   pm->add_after_named_pass (pass, new String ("ast"));
}

<reserved>extern</reserved> "C" <reserved>void</reserved> run_ast (AST::PHP_script* in, Pass_manager* pm, String* option)
{
   <reserved>int</reserved> num_statements = count(in->statements);
   cout &lt;&lt; num_statements &lt;&lt; " statements found" &lt;&lt; endl;
}
</programlisting>

<para>
	The overall structure of this plugin should be fairly clear. We count all
	the statements in the outermost list of statements, and then consider each
	statement in turn to check if there are any statements nested inside them.
	This plugin will now report the correct number of statements for our example
	with the <code>if</code> statement. However, if will report an invalid
	number of statements for examples with other types of statements. For
	example, it will report only two statements for
</para>

<programlisting>
&lt;?<reserved>php</reserved>
   $x = 5;
   <reserved>while</reserved>($x--)
   {
      <reserved>echo</reserved> $x;
   }
?&gt;
</programlisting>

<para>
	Of course, we can fix the plugin by testing for <code>while</code>
	statements. And for <code>do</code> statements. And for
	<code>foreach</code>, <code>switch</code>, <code>try</code>, etc. As
	mentioned, manually dealing with the syntax tree is a laborious process!
	Even something as simple as counting the number of statements in a script
	becomes a large program. Fortunately, there is a much easier solution.
</para> 

</section>

<section>

<title>The Easy Solution</title>

<para>
	Fortunately, &phc will do all this for you automatically! There is a
	standard &ldquo;do-nothing&rdquo; tree traversal predefined in &phc in the
	form of a class called <code>AST::Visitor</code> (defined in
	<filename>AST_visitor.h</filename>). <code>AST::Visitor</code>
	contains methods for each type of node in the tree. &phc will automatically
	traverse the abstract syntax tree for you, and call the appropriate method
	at each node.
</para>

<para>
	In fact, there are <emphasis>two</emphasis> methods defined for each type of
	node. The first method, called <code>pre_something</code>, gets called on a
	node <emphasis>before</emphasis> &phc visits the children of the node. The
	second method, called <code>post_something</code>, gets called on a node
	<emphasis>after</emphasis> &phc has visited the children of the node.  For
	example, <code>pre_if</code> gets called on an <code>If</code>,
	before visiting the statements in the <code>iftrue</code> and
	<code>iffalse</code> clauses of the <code>If</code>. After all the
	statements, have been visited, <code>post_if</code> gets called.
</para>

<para>
	So, here is an alternative and much easier solution for our problem. This
	plugin will actually count <emphasis>all</emphasis> statements in a script,
	without having to worry about all the different ways statements can be
	embedded in other statements. Moreover, even if the internal representation
	of &phc; changes (for example, if another type of statement gets added),
	this plugin will still work as-is.
</para>

<programlisting>
<reserved>#include</reserved> "AST_visitor.h"
<reserved>#include</reserved> &lt;pass_manager/Plugin_pass.h&gt;

<reserved>class</reserved> Count_statements : <reserved>public</reserved> AST::Visitor
{
<reserved>private</reserved>:
   <reserved>int</reserved> num_statements;

<reserved>public</reserved>:
   <emphasis>// Set num_statements to zero before we begin</emphasis>
   <reserved>void</reserved> pre_php_script(AST::PHP_script* in)
   {
      num_statements = 0;
   }

   <emphasis>// Print the number of function calls when we are done</emphasis>
   <reserved>void</reserved> post_php_script(AST::PHP_script* in)
   {
      cout &lt;&lt; num_statements &lt;&lt; " statements found" &lt;&lt; endl;
   }
   
   <emphasis>// Count the number of function calls</emphasis>
   <reserved>void</reserved> post_statement(AST::Statement* in)
   {
      num_statements++;
   }
};

<reserved>extern</reserved> "C" <reserved>void</reserved> load (Pass_manager* pm, Plugin_pass* pass)
{
   pm->add_after_named_pass (pass, new String ("ast"));
}

<reserved>extern</reserved> "C" <reserved>void</reserved> run_ast (AST::PHP_script* in, Pass_manager* pm, String* option)
{
	Count_statements cfc;
	in->visit(&amp;cfc);
}
</programlisting>

<para> We override a number of methods of the <code>AST_visitor</code> class to
implement the functionality we need; the traversal is then taken care of by
&phc;. </para>

</section>

<section>

<title>Pre and Post Methods</title> 

<para> We need to be precise about the order in which &phc calls all these
methods. Suppose we have a node <code>Foo</code> (say, an if-statement), which
<emphasis>is-a</emphasis> <code>Bar</code> (say, statement), which itself
<emphasis>is-a</emphasis> <code>Baz</code> (say, commented node).  Then &phc;
calls the visitor methods in the following order: </para>

<orderedlist>
<listitem><para><code>pre_baz</code></para></listitem>
<listitem><para><code>pre_bar</code></para></listitem>
<listitem><para><code>pre_foo</code></para></listitem>
<listitem><para><code>children_foo</code> (visit the children of <code>foo</code>)</para></listitem>
<listitem><para><code>post_foo</code></para></listitem>
<listitem><para><code>post_bar</code></para></listitem>
<listitem><para><code>post_baz</code></para></listitem>
</orderedlist>

<para> Just to emphasise, if all of the visitor methods listed above are
implemented, they will <emphasis>all</emphasis> be invoked, in the order listed
above. So, implementing a more specific visitor (<code>pre_foo</code>) does not
inhibit the more general method (<code>pre_bar</code>) from being invoked. You
can run the <filename>plugins/tutorials/show_traversal_order.la</filename> from
the &phc; distribution to see this in action. </para>

<note>
<para>(Advanced users) As mentioned above, if you implement <code>pre_if</code>
(say), the more general methods such as <code>pre_statement</code> or
<code>pre_node</code> will still be invoked. It is possible to override
<code>pre_if_chain</code> instead; if you override <code>pre_if_chain</code>,
you are responsible for calling the more general methods manually. If you
don't, they will not be called at all. </para>
</note>

</section>

</chapter>
