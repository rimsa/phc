.. include:: include.rst

.. _grammar:

The Abstract Grammar
====================

This is the full and authoritative definition of the |phc| abstract grammar for
PHP in :program:`maketea` format (this can also be found in
:file:`src/generated_src/ast.tea` in the distribution). For a description of
the structure of the grammar, and how it converts to C++ code, refer to the
:ref:`maketeatheory`.  


Overall Structure
-----------------

.. sourcecode:: haskell

   PHP_script ::= Statement* ;

   Class_def ::=
      Class_mod CLASS_NAME extends:CLASS_NAME? 
      implements:INTERFACE_NAME* Member* ;
   Class_mod ::= "abstract"? "final"? ;

   Interface_def ::= INTERFACE_NAME extends:INTERFACE_NAME* Member* ;

   Member ::= Method | Attribute ;

   Method ::= Signature Statement*? ;
   Signature ::= Method_mod is_ref:"&"? METHOD_NAME Formal_parameter* ;
   Method_mod ::= "public"? "protected"? "private"? "static"? "abstract"? "final"? ;
   Formal_parameter ::= Type is_ref:"&"? 
      var:Name_with_default ;
   Formal_parameter ::= Type is_ref:"&"?
      var:Name_with_default ;
   Type ::= CLASS_NAME? ;
   Name_with_default ::= VARIABLE_NAME Expr? ;

   Attribute ::= Attr_mod vars:Name_with_default* ;
   Attr_mod ::= "public"? "protected"? "private"? "static"? "const"?  ;




Statements
----------

.. sourcecode:: haskell

   Statement ::=
        Class_def | Interface_def | Method
      | Return | Static_declaration | Global
      | Try | Throw | Eval_expr
      | If | While | Do | For | Foreach
      | Switch | Break | Continue
      | Declare | Nop
      ;

   If ::= Expr iftrue:Statement* iffalse:Statement* ;
   While ::= Expr Statement* ;
   Do ::= Statement* Expr ;
   For ::= init:Expr? cond:Expr? incr:Expr? Statement* ;
   Foreach ::= Expr key:Variable? is_ref:"&"? 
      val:Variable Statement* ;

   Switch ::= Expr Switch_case* ;
   Switch_case ::= Expr? Statement* ;
   Break ::= Expr? ;
   Continue ::= Expr? ;
   Return ::= Expr? ;

   Static_declaration ::= vars:Name_with_default* ;
   Global ::= Variable_name* ;

   Declare ::= Directive+ Statement* ;
   Directive ::= DIRECTIVE_NAME Expr ;

   Try ::= Statement* catches:Catch* ;
   Catch ::= CLASS_NAME VARIABLE_NAME Statement* ;
   Throw ::= Expr ;

   Eval_expr ::= Expr ;

   Nop ::= ;



Expressions
-----------

.. sourcecode:: haskell

   Expr ::=
        Assignment 
      | Cast | Unary_op | Bin_op 
      | Constant | Instanceof
      | Variable | Pre_op 
      | Method_invocation | New 
      | Literal 
      | Op_assignment | List_assignment 
      | Post_op | Array | Conditional_expr | Ignore_errors 
      ;

   Literal ::= INT<long> | REAL<double> | STRING<String*> | BOOL<bool> | NIL<> ;
      
   Assignment ::= Variable is_ref:"&"? Expr ;
   Op_assignment ::= Variable OP Expr ;

   List_assignment ::= List_element?* Expr ;
   List_element ::= Variable | Nested_list_elements ;
   Nested_list_elements ::= List_element?* ;

   Cast ::= CAST Expr ;
   Unary_op ::= OP Expr ;
   Bin_op ::= left:Expr OP right:Expr ;

   Conditional_expr ::= 
      cond:Expr iftrue:Expr iffalse:Expr ;
   Ignore_errors ::= Expr ;

   Constant ::= CLASS_NAME? CONSTANT_NAME ;

   Instanceof ::= Expr Class_name ;

   Variable ::= Target? Variable_name array_indices:Expr?* ;
   Variable_name ::= VARIABLE_NAME | Reflection ;
   Reflection ::= Expr ;

   Target ::= Expr | CLASS_NAME ;

   Pre_op ::= OP Variable ;
   Post_op ::= Variable OP ;

   Array ::= Array_elem* ;
   Array_elem ::= key:Expr? is_ref:"&"? val:Expr ;

   Method_invocation ::= Target? Method_name Actual_parameter* ;
   Method_name ::= METHOD_NAME | Reflection ;

   Actual_parameter ::= is_ref:"&"? Expr ;

   New ::= Class_name Actual_parameter* ;
   Class_name ::= CLASS_NAME | Reflection ;



Additional Structure
--------------------

.. sourcecode:: haskell

   Commented_node ::= 
        Member | Statement | Interface_def | Class_def | Switch_case | Catch 
      ;

   Identifier ::=
        INTERFACE_NAME | CLASS_NAME | METHOD_NAME | VARIABLE_NAME 
        | CAST | OP | CONSTANT_NAME
        | DIRECTIVE_NAME 
      ; 

   Source_rep ::= Identifier | Literal ;


.. _mixin:

Mix-in Code
-----------

The code generated based on the grammar listed above can be extended by
"mix-in" code, which adds fields or methods to the class structure generated by
|phc|. For a full listing of the mix-in code, see
:file:`src/generated_src/ast.tea` in the |phc| distribution. 
