<chapter id="devintro">
<title id="devintro.title">Introduction</title>

<section>
<title></title>

<para> From the start, one of the design goals of &phc; has been to provide a
useful framework for writing applications that process PHP scripts. &phc parses
PHP code into an internal representation known as an <emphasis>abstract syntax
tree</emphasis> or <emphasis>AST</emphasis>.  Applications can process PHP code
by analysing and modifying this abstract representation in one of two ways:
</para>  

<itemizedlist>

<listitem><para> &phc supports <emphasis>plugins</emphasis>. Plugins are
modules that can be loaded into &phc, which get access to the AST. &phc;
provides sophisticated support for writing operations over the AST through the
<emphasis>Tree Transformation API</emphasis>. </para></listitem> 

<listitem><para> Alternatively, you can export the AST to
<emphasis>XML</emphasis>. You can then process the XML in any way you like, and
then use &phc to convert the XML back to PHP syntax.  </para></listitem>

</itemizedlist>

<para> The <xref linkend="treetutorials" endterm="treetutorials.title"> explain
how to write plugins for &phc, and provide numerous examples. You will find
<xref linkend="reference" endterm="reference.title"> very useful when writing
serious applications using &phc;.

<para> You can download the documentation for this and for older versions from
the <ulink url="http://www.phpcompiler.org/src/archive/">archive</ulink>.
Moreover, although we have tried to document &phc as well as we can, if
anything is still unclear, please let us know by sending an email to the <ulink
url="http://www.phpcompiler.org/contact.html">mailing list</ulink>.  </para>

</section>

<section>
<title>System Requirements</title>

<para> If you want to modify the internals of &phc in other ways than through
the explicit API we provide for doing so, you will following tools listed
below, in addition to those detailed in the user manual (<xref
linkend="install">).  However, most people should not need these tools (even if
you are implementing tools based on &phc). </para>

<itemizedlist>
<listitem><para><code>flex</code> if you need to modify the lexical
analyser</para></listitem>
<listitem><para><code>bison</code> if you need to modify the syntax
analyser</para></listitem>
<listitem><para><ulink url="http://www.maketea.org">maketea</ulink> if you
want to modify the &phc grammar (or the AST classes)</para></listitem>
<listitem><para><ulink
url="http://www.gnu.org/software/gengetopt/gengetopt.html">gengetopt</ulink>
if you need to add additional command line arguments; you will need version
0.20 or higher</para></listitem>
<listitem><para><ulink
url="http://www.gnu.org/software/gperf/gperf.html">gperf</ulink> if you need
to modify the list of keywords recognized by the lexical
analyser</para></listitem>
</itemizedlist>

<para>It is possible to link &phc to the Boehm garbage collector. If you wish
to link your application with &phc, this may be necessary. However, this
feature is experimental and seems to lead to runtime errors on some systems.
Use with care. </para> 

</section>

<section>

<title>Demonstration</title>

<para> This section is intended as a quick introduction outlining what the
current release of &phc can do for you. It does not explain everything in
detail. </para>

<section>
<title>The Source Program</title>

<para> Consider the following simple PHP script. </para>

<programlisting>
&lt;?<reserved>php</reserved>
   <reserved>function</reserved> foo()
   {
      <reserved>return</reserved> 5;
   }

   $foo = foo();
   <reserved>echo</reserved> "foo is $foo&lt;br&gt;";
?&gt;
</programlisting>

<para> Internally this program gets represented as an abstract syntax tree, as shown in figure <xref linkend="ast">. </para>

<figure id="ast">
<title>Abstract syntax tree for the demo example</title>
<mediaobject>
<imageobject>
<imagedata fileref="img/demo.jpg">
</imageobject>
</mediaobject>
</figure>

</section>
<section>

<title>The Transform</title>

<para> Suppose we want to rename function <code>foo</code> to
<code>bar</code>. This is done by the following plugin: </para>

<programlisting>
<reserved>#include</reserved> "AST_visitor.h"

<reserved>class</reserved> Rename_foo_to_bar : <reserved>public</reserved> AST_visitor
{
   <reserved>void</reserved> pre_method_name(Token_method_name* in)
   {
      <reserved>if</reserved>(*in->value == "foo")
         in->value = <reserved>new</reserved> String("bar");
   }
};

<reserved>extern</reserved> "C" <reserved>void</reserved> process_ast(AST_php_script* php_script)
{
    Rename_foo_to_bar f2b;
    php_script->visit(&amp;f2b);
}
</programlisting>					

</section>
<section>

<title>The Result</title>

<para> Running &phc gives </para>

<programlisting>
&lt;?<reserved>php</reserved>
   <reserved>function</reserved> bar()
   {
      <reserved>return</reserved> 5;
   }

   $foo = bar();
   <reserved>echo</reserved> "foo is " . $foo . "&lt;br&gt;";
?&gt;
</programlisting>

<para> where the name of the function has been changed, while the name of the
variable remained unaltered, as has the text <code>"foo"</code> inside
the string. It's that simple! Of course, in this example, it would
have been quicker to do it by hand, but that's not the point; the
example shows how easy it is to operate on PHP scripts within the
&phc framework. </para>

</section>
</section>

<section>

<title>Writing Plugins</title>

<para><xref linkend="gettingstarted" endterm="gettingstarted.title"> introduces
writing plugins for &phc;. It then explains how &phc represents PHP scripts
internally, and shows how to write a first (but ultimately wrong) attempt at
simple plugin that counts the number of statements in a PHP script.</para>

<para><xref linkend="treetutorial1" endterm="treetutorial1.title"> introduces
the support that &phc offers for traversing (and transforming) scripts. It
shows how to write a plugin that correctly counts the number of statements in a
script.</para>

<para><xref linkend="treetutorial2" endterm="treetutorial2.title"> shows how
you can modify nodes in the tree (without modifying the structure of the tree).
It shows how to replace calls to <code>mysql_connect</code> by calls to
<code>dbx_connect</code>.</para>

<para><xref linkend="treetutorial3" endterm="treetutorial3.title"> shows how
you can modify the structure of the tree. It works through an example that
removes unnecessary string concatenations (for example, <code>$a .  ""</code>
is replaced by just <code>$a</code>).</para>	

<para><xref linkend="treetutorial4" endterm="treetutorial4.title"> explains an
advanced features of pattern matching, and shows an important technique: the
use of state in transformations (where one transformation depends on a previous
transformation). It shows how to write a program that renames all functions
<code>foo</code> in a script to <code>db_foo</code>, if there are calls to a
database engine within <code>foo</code>.</para>

<para><xref linkend="treetutorial5" endterm="treetutorial5.title"> explains how
to change the order in which the children of a node are visited, avoid visiting
some children, or how to execute a piece of code in between visiting two
children.</para>

<para><xref linkend="treetutorial6" endterm="treetutorial6.title"> shows how to
define transformations that replace nodes in the tree by multiple other nodes,
and how to delete nodes from the tree. It also shows to call the &phc parser
and unparsers from plugins.</para>

</section>
<section>

<title>Reference</title>

<para>&phc represents PHP scripts internally as an abstract syntax tree. The
structure of this tree is dictated by the <xref linkend="grammar"
endterm="grammar.title">. The grammar definition is a very important part of
&phc;.

<para>&phc's view on the world (as dictated by the grammar) does not completely
agree with the PHP standard view.  <xref linkend="representingphp"
endterm="representingphp.title"> describes how the various PHP constructs get
translated into the abstract syntax.</para>

<para><xref linkend="generatedcode" endterm="generatedcode.title"> gives an
overview of the AST classes, the tree visitor API and the tree transformation
API from a programmer's perspective.</para>

<para><application>Maketea</application> is a tool bundled with &phc which,
based on a grammar definition of a language, generates a C++ hierarchy for the
corresponding abstract syntax tree, a tree transformation and visitor API, and
deep cloning, deep equality and pattern matching on the AST. <xref
linkend="maketeatheory" endterm="maketeatheory.title">  explains some of the
theory behind <application>maketea</application>; in particular, the grammar
formalism, the mapping from the grammar to the AST classes, and the derivation
of the tree transformation API.</para>
	
</section>


</chapter>
