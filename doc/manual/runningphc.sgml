<chapter id="runningphc">
<title id="runningphc.title">Running &phc</title>

<para> Once you have installed &phc (see <xref linkend="install"
endterm="install.title">), run it by typing </para>

<screen>
phc --help
</screen>
		
<para>
	You should see
</para>

<screen>
phc 0.2.0

Usage: phc [OPTIONS]... [FILES]...

  -h, --help               Print help and exit
      --full-help          Print help, including hidden options, and exit
  -V, --version            Print version and exit

GENERAL OPTIONS:
  -v, --verbose            Verbose output  (default=off)
  -c, --compile            Compile  (default=off)
      --pretty-print       Pretty print input according to the Zend style 
                             guidelines  (default=off)
      --obfuscate          Obfuscate input  (default=off)
      --run=STRING         Run the specified plugin (may be specified multiple 
                             times)
      --r-option=STRING    Pass option to a plugin (specify multiple flags in 
                             the same order as multiple plugins - 1 option only 
                             per plugin)
  -d, --define=STRING      Define ini entry (only affects -c and --include)

INPUT OPTIONS:
      --read-xml=passname  Assume the input is in XML format. Start processing 
                             after the named pass
      --include            Parse included or required files at compile-time  
                             (default=off)

COMPILATION OPTIONS:
  -C, --c-option=STRING    Pass option to the C compile (e.g., -C-g; can be 
                             specified multiple times)
      --extension=NAME     Generate a PHP extension called NAME instead of a 
                             standalone application
  -O, --optimize=STRING    Optimize  (default=`0')
  -o, --output=FILE        Place executable into file FILE
  -e, --execute            Run executable after compiling (implies -c)  
                             (default=off)

PRETTY PRINTING OPTIONS:
      --next-line-curlies  Output the opening curly on the next line instead of 
                             on the same line  (default=off)
      --no-leading-tab     Don't start every line in between <?php .. ?> with a 
                             tab  (default=off)
      --tab=STRING         String to use for tabs while unparsing  
                             (default=`	')
      --no-hash-bang       Do not output any #! lines  (default=off)
</screen>

<para>
	Now write a very small PHP script, for example
</para>

<programlisting>
&lt;? <reserved>echo</reserved> "Hello world!"; ?&gt;
</programlisting>

<para>
	and save it to <filename>helloworld.php</filename>. Then
	run &phc:
</para>

<screen>
phc --pretty-print helloworld.php
</screen>

<para>
	This should output a pretty-printed version of your PHP
	script back to standard output:
</para>
			
<programlisting>
&lt;?<reserved>php</reserved>
   <reserved>echo</reserved> "Hello world!";
?&gt;
</programlisting>

<para>
	You can see a list of options controlling the style of pretty printing, using the
	<code>--full-help</code> option.
</para>

<!-- TODO:
	what can phc do:
		XML
		print canonical form
		run plugins
		combine files
		obfuscate
		warnings
-->
<section>
<title>Compiling executables</title>

<para>
	&phc can compile either executables or extensions. To compile an executable,
	&phc creates C code, which it compiles and links to the PHP embed SAPI.
	Since it links to PHP, you have access to all of PHP's large built-in
	standard library. In order to compile the "hello world" executable from
	before, run
</para>

<screen>
phc -c helloworld.php -o helloworld
</screen>

<para>
	This creates an executable <code>helloworld</code>, which can then be run
</para>

<screen>
./helloworld
</screen>

<para>
	If you prefer to run your executable immediately after it compiles, use the
	<code>-e</code>. &phc will compile your program, then immediately execute
	it. You can also view the C code generated by &phc:
</para>

<screen>
phc --generate-c helloworld.php > helloworld.c
</screen>

<para>
	One of the advantages of &phc is that it can optimize your program. Using
	the <code>-O</code> flag, you can instruct &phc to analyse your source code,
	and perform simple optimizations. On simple benchmarks, this can increase
	the speed of your application by 50%. To optimize:
</para>

<screen>
phc -O2 -c helloworld.php -o helloworld
</screen>

<para>
	&phc generates C code, which is then compiled by <code>gcc</code>. To see
	the command passed to <code>gcc</code> by &phc, use the <code>-v</code>
	flag.
</para>

<para>
	If you
	specify the <code>-O</code> flag, &phc will also pass the <code>-O</code>
	flag to <code>gcc</code>, which will optimize your code further. The
	argument to the <code>-O</code> flag must therefore be usable by
	<code>gcc</code>, so it must be any of <code>-O0</code> (default),
	<code>-O1</code>, <code>-O2</code>, <code>-O3</code> or <code>-Os</code>.
	Consult the <ulink
	url="http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options">gcc
	manual</ulink> for more details.
</para>

<para>
	It is also possible to pass command-line arguments to <code>gcc</code>
	through &phc, using the <code>-C</code> flag. For example, to disable
	inlining of the generated code by <code>gcc</code>, using
	<code>-fno-inline</code>:
</para>

<screen>
phc -c -O2 helloworld.php -o helloworld -C-fno-inline
</screen>


</section>

<section>
<title>Compiling web applications</title>

<warning>
<para>
	In order to compile web applications, it is currently necessary to alter
	your <filename>php.ini</filename> file, or have access to the root account.
	We welcome suggetions of a different method which avoids these requirements,
	especially if they would work in a shared hosting environment.
</para>
</warning>


<warning>
<para>
	This section is experimental. Please <ulink
	url="http://www.phpcompiler.org/mailinglist.html">report any
	problems</ulink>.
</para>
</warning>

<para>
	To compile helloworld.php, as above, initially generate the C file:
</para>

<screen>
phc --extension=helloworld --generate-c > helloworld.c
</screen>

<para>
	Now create an extension around <filename>helloworld.c</filename>. While we
	give an overview of the process, significantly more detail can be found in
	the <ulink url="http://devzone.zend.com/node/view/id/1021">Zend Extension
	Writing Tutorial</ulink> and in <ulink
	url="http://www.amazon.com/dp/067232704X">Extending and Embedding
	PHP</ulink>. To begin, create a new directory for the extension. We'll use
	<filename>ext/</filename> in our example. Copy
	<filename>helloworld.c</filename> into <filename>ext/:</filename>
</para>

<screen>
cp helloworld.c ext/
</screen>

<para>
	Create a new file, <filename>ext/config.m4</filename>, by copying the
	following, and changing instances of "helloworld" appropriately:
</para>

<screen>
PHP_ARG_ENABLE(helloworld, whether to enable Hello World support,
[ --enable-helloworld   Enable Hello World support])

if test "$PHP_HELLOWORLD" = "yes"; then
  AC_DEFINE(HAVE_HELLOWORLD, 1, [Whether you have Hello World])
  PHP_NEW_EXTENSION(helloworld, helloworld.c, $ext_shared)
fi
</screen>

<para>
	In the previous section, we described using the PHP embed SAPI. If you
	installed a copy of PHP with <code>--enable-embed</code> enabled, it is
	important that that is not the version you use for the following commands.
	Instead, you should the same version as your webserver uses. From the ext/ directory, run:
	<!-- TODO wont they need php5-dev? for headers. the embed SAPI will provide
	the wrong settings -->
</para>

<screen>
phpize --with-php-config=/usr/bin/php-config
./configure --enable-helloworld
</screen>

<para>
	Build and install the extension (if you dont have root, refer instead to
	<xref linkend=alternate.method endterm=alternate.method.title>):
</para>

<screen>
make
sudo make install
</screen>

<para>
	In your web folder, replace the existing <filename>helloworld.php</filename> file contents with the following:
</para>

<screen>
<?php
	dl ("helloworld.so");
	__MAIN__ ();
?>
</screen>

<para>
	If the <code>dl()</code> function is not enabled in your <filename>php.ini</filename> file, enable it:
</para>

<screen>
enable_dl = On;
</screen>

<para>
	Accessing <filename>helloworld.php</filename> should now work. 
</para>



<section id=alternate.method>
<title id=alternate.method.title>Alternatives</title>

<para>
	Instead of setting <code>enable_dl</code>, you can instead load the
	extension manually in your <filename>php.ini</filename> file:
</para>

<screen>
extension=helloworld
</screen>

<para>
	You can also avoid installing the extension using <code>sudo make
	install</code> by adding an alternate extension directory:
</para>

<screen>
extensions_dir="/full/path/to/ext"
</screen>

	
</section>
</section>

<section>

<title>Graphical Output</title>

<para>
	&phc represents PHP scripts internally as trees (this is
	further explained in <xref linkend="treetutorial1">). If
	you have a DOT viewer installed on your system (for
	example, <ulink
	url="http://www.graphviz.org">graphviz</ulink>), you can
	view this tree graphically. First, ask &phc to output
	the tree in DOT format:
</para>

<screen>
./phc --dump-ast-dot helloworld.php &gt; helloworld.dot
</screen>

<para> You can then view the tree (<filename>helloworld.dot</filename>) using
Graphviz. In most Unix/Linux systems, you should be able to do </para>

<screen>
dotty helloworld.dot
</screen>

<para> And you should see the tree; it should look similar to the tree shown in
figure <xref linkend="helloworldtree">. </para>

<figure id="helloworldtree">
<title>Abstract syntax tree for &ldquo;Hello world&rdquo;</title>
<mediaobject>
<imageobject>
<imagedata fileref="img/helloworld.jpg">
</imageobject>
</mediaobject>
</figure>

</section>
<section id="xml">

<title id="xml.title">Writing and Reading XML</title>

<para> &phc can also output an XML representation of the tree. You can use this
representation if you want to process PHP scripts without using the &phc
framework, but yet using the &phc abstract representation of PHP scripts. To
generate an XML version of the tree, run </para>

<screen>
./phc --dump-ast-xml helloworld.php &gt; helloworld.xml
</screen>

<para> &phc can also read the XML back in, after which all the usual features
of &phc are again available; in particular, it is possible to read an XML file,
and write PHP syntax. To convert the XML file we just generated back to PHP
syntax, run </para>

<screen>
./phc --read-ast-xml --pretty-print helloworld.xml
</screen>

<para>The generated XML uses the schema <ulink
url="http://www.phpcompiler.org/phc-1.0">http://www.phpcompiler.org/phc-1.0</ulink>.
</para>

</section>
<section>

<title>Compile-time Includes</title>

<para> &phc now has initial support for compile-time processing of PHP's
<code>include</code> built-in.  Enabling this feature inserts the included
statements in the AST in the place of the <code>include</code> statement.
Included functions become part of the %MAIN% class, and included classes become
part of the script.  In the event that &phc is not able to process the
<code>include</code> statement (for example, if it would require using the
<code>remote</code> feature of <code>include</code>), a warning is issued, and
the <code>include</code> statement is left in place. To enable this support,
run </para>

<screen>
./phc --compile-time-includes script_with_includes.php
</screen>

<para> The include support is intended to mimic <ulink
url="http://php.net/manual/en/function.include.php">PHP's include
built-in</ulink>, as far as can be achieved at compile time. &phc supports:
</para>

<itemizedlist>
	<listitem><para>Moving included statements to the point at which
	<code>include</code> was called. Naturally, these statement's use the
	variable scope at the point at which they are included,</para></listitem>

	<listitem><para>Preserving <code>__FILE__</code> and <code>__LINE__</code>
	statements,</para></listitem>

	<listitem><para>Moving included functions to the <code>%MAIN%</code> class,
	and importing the included classes,</para></listitem>

	<listitem><para><code>include</code>, and <code>require</code>. If the
	specified file cannot be found, parsed, or if the argument to
	<code>include</code> is not a string literal, the include statement is left
	in place.</para></listitem>
</itemizedlist>

<para> &phc does not support: </para>

<itemizedlist>
	<listitem><para>Return values in included scripts. We intend to support
	these in the future. They will likely be supported in a later stage of the
	compilation process, instead of in the AST,</para></listitem>

	<listitem><para>Calling <code>include</code> on anything other than a
	literal string containing the filename of a local file. This excludes
	variables and remote files. These may be supported when more static
	analyses are available,</para></listitem>

	<listitem><para><code>include_once</code> and <code>require_once</code>, as
	we cannot guarantee that the file to be included is not included elsewhere.
	These statements will not be processed, and combinations of
	<code>include</code> or <code>require</code> and <code>include_once</code>
	or <code>require_once</code> may cause incorrect behaviour with this option
	set,</para></listitem>

	<listitem><para>Updating <code>get_included_files()</code> to reflect the
	included files.</para></listitem>
</itemizedlist>

</section>
</chapter>
