#!/usr/bin/env php
<?php

	/* Logging detail:
	 *	All data is stored, in a log. Before the log is created, all
	 *	data is kept in a string, which is emailed to me on failure.
	 */

	ob_start (); // keep all output

	$REPO = "http://phc.googlecode.com/svn/trunk";
	$CWD = getcwd ();
	$TEST_DIR = "$CWD/testing";
	$RESULTS_DIR = "$CWD/results";
	$DB_FILENAME = "$RESULTS_DIR/results.db";
	$LATEST_REVISION =  get_current_revision (); // use SVN to get this

	// start the DB
	initialize_db ();

	// Prepare the test
	$start_time = time ();
	list ($REV, $AUTHOR, $DATE) = get_working_revision () or svn_problem ();
	$PREV_REV = $REV - 1;
	initialize_revision_test ();

	// Do SVN work - fails mean tet wasnt affected
	try
	{
		$log = c ("svn log -r $REV $REPO");
		$diff = c ("svn diff -r $REV:$PREV_REV");

		save ("LOG:\n$log\n\nDIFF:\n$diff", "svn_log");

		c ("svn export -q --revision=$REV $REPO $TEST_DIR");
	}
	catch (Exception $e) { svn_problem (); }

	// Do test work - fails mean test doesnt work
	try
	{
		cd ("touch src/generated/*");
		save (cd ("./configure --prefix=$TEST_DIR/installed"), "configure");

		// make
		save (cd ("make"), "make");
		$results = save (cd ("php test/framework/driver.php -q -p"), "test");
		c ("mv " . readlink ("$TEST_DIR/test/logs/latest"). " $LOG_DIR/test_logs"); 
		store_test_results ($results, "tests");

		// make install
		save (cd ("make install"), "install");
		$results = save (cd ("php test/framework/driver.php -q -i -p"), "install_test");
		c ("mv ".readlink("$TEST_DIR/test/logs/latest")." $LOG_DIR/install_test_logs"); 
		store_test_results ($results, "install_tests");

		// Finish up
		finalize_revision_test ();
	}
	catch (Exception $e) { test_problem (); }



	function svn_problem ()
	{
		print "SVN problem. Wait 5 mins";
		save_log ();
		print "SVN problem. Wait 5 mins";
		sleep (300);
		die ();
	}

	function script_problem ()
	{
		print "Test problem, saving and mailing error\n";
		save_log ();

		$info = ob_get_contents ();
		mail ("paul.biggar@gmail.com", "Script error", $info);

		die ();
	}

	function test_problem ()
	{
		global $REV, $AUTHOR, $DATE, $LATEST_REVISION;
		$end_time = time ();
		print "Test problem, saving error\n";
		e ("INSERT INTO complete VALUES ($REV, NULL, $LATEST_REVISION, '$AUTHOR', '$DATE', $end_time, 1)");

		save_log ();
		die ();
	}

	function strip_console_codes ($string)
	{
		// strip console codes
		$string = preg_replace("/\[1;\d\dm/", "", $string);
		$string = preg_replace("/\[0m/", "", $string); 
		return $string;
	}

	function matcher_xxx ($string)
	{
		# TODO InterpretObfuscated  avg  0s; max(135) 11s  Failure ( 25/213 failed)
	}

	function matcher_902 ($string)
	{
		$string = strip_console_codes ($string);
		#Demi_eval_true     Failure:   0 P,   8 F,   0 T,   2 S
		$results = preg_match_all ("/(\S+)\s+\S+:\s+(\d+) P,\s*(\d+) F,\s*(\d+) T,\s*(\d+) S/", $string, $matches, PREG_SET_ORDER);

		if ($results)
		{
			array_map ("array_shift", &$matches);
			return $matches;
		}

		return false;
	}

	function store_test_results ($result_string, $table_name)
	{
		global $REV;
		# there a few different test formats, so add them as we go
		$matchers[] = "matcher_902";
		foreach ($matchers as $matcher)
		{
			$results = $matcher ($result_string);
			if ($results !== false)
				break;
		}

		if ($results === false)
		{
			die ("No matches found");
		}

		foreach ($results as $result)
		{
			list ($name, $pass, $fail, $timeout, $skip) = $result;
			e ("INSERT INTO $table_name VALUES ($REV, '$name', $pass, $fail, $timeout, $skip)");
			$total_pass += $pass;
			$total_fail += $fail;
			$total_timeout += $timeout;
			$total_skip += $skip;
		}

		e ("INSERT INTO $table_name VALUES ($REV, 'Total', $total_pass, $total_fail, $total_timeout, $total_skip)");
	}

	function initialize_db ()
	{
		global $RESULTS_DIR;
		create_dir ($RESULTS_DIR);

		global $DB, $DB_FILENAME;
		$DB = new PDO ("sqlite:$DB_FILENAME");
		e ("CREATE TABLE IF NOT EXISTS complete (revision, time, test_revision, author, commit_date, test_date, failed)");
		e ("CREATE TABLE IF NOT EXISTS tests (revision, testname, pass, fail, timeout, skip)");
		e ("CREATE TABLE IF NOT EXISTS install_tests (revision, testname, pass, fail, timeout, skip)");
	}

	function initialize_revision_test ()
	{
		global $start_time, $REV, $LOG_DIR, $TEST_DIR, $RESULTS_DIR;
		$time = time ();

		# create directory structure
		$LOG_DIR = "$RESULTS_DIR/$REV";
		del_dir ($TEST_DIR);
		del_dir ($LOG_DIR);
		create_dir ($LOG_DIR);

		e ("DELETE FROM complete WHERE revision == $REV");
		e ("DELETE FROM tests WHERE revision == $REV");
		e ("DELETE FROM install_tests WHERE revision == $REV");
	}

	function save_log ()
	{
		$log = ob_get_contents ();
		var_dump ($log);
		save ($log, "log");
	}

	function finalize_revision_test ()
	{
		global $LATEST_REVISION, $REV, $AUTHOR, $START_TIME, $DATE;
		$end_time = time ();
		$time = $end_time - $START_TIME;

		e ("INSERT INTO complete VALUES ($REV, $time, $LATEST_REVISION, '$AUTHOR', '$DATE', $end_time, 0)");

		save_log ();
	}

	// delete contents
	function del_dir ($dir)	{ c ("rm -Rf $dir"); }
	function create_dir ($dir) { c ("mkdir -p $dir"); }

	// C for Command. If the command fails, log the result and die
	function c ($command)
	{
		print "Running command '$command'\n";
		exec ("$command 2>&1", $result, $ret_val);
		if ($ret_val !== 0)
			throw new Exception ();

		$result = join ("\n", $result);
		print "Returning result '$result'\n";
		return $result;
	}

	// CD for Command in Directory. Run the COMMAND from the working
	// directory.
	function cd ($command)
	{
		global $TEST_DIR;
		$cwd = getcwd ();
		print "Entering $TEST_DIR\n";
		chdir ($TEST_DIR) or x ("Couldnt change dir to $TEST_DIR");
		$result = c ($command);
		chdir ($cwd);
		print "Leaving $TEST_DIR for $cwd\n";
		return $result;
	}

	function save ($string, $log_name)
	{
		global $LOG_DIR;
		assert (isset ($LOG_DIR));
		file_put_contents ("$LOG_DIR/$log_name.log", $string);

		return $string;
	}


	// E for Exec
	function e ($sql)
	{
		print "Execing '$sql'\n";
		global $DB;
		if ($DB->exec ($sql) === FALSE)
		{
			var_dump ($DB->errorInfo());
			script_problem ();
		}
	}

	function get_svn_info ($rev)
	{
		$output = c ("svn info $REPO -r $rev");

		preg_match ("/^Last Changed Author: (.*)$/m", $output, $matches);
		$author = $matches[1];

		preg_match ("/^Revision: (.*?)$/m", $output, $matches);
		$revision = $matches[1];
		assert ($revision == $rev);

		preg_match ("/^Last Changed Date: (.*)$/m", $output, $matches);
		$date = $matches[1];

		return array ($rev, $author, $date);
	}

	function get_working_revision () 
	{
		// Get list of processed revisions
		global $LATEST_REVISION, $DB;
		$revs = $DB->query ("SELECT revision FROM complete ORDER BY revision ASC")->fetchAll(PDO::FETCH_COLUMN);

		// Go backwards until we find an unprocessed revision
		sort ($revs);
		for ($i = $LATEST_REVISION; $i > 0; $i--)
		{
			if (array_pop ($revs) != $i)
				return get_svn_info ($i);
		}
		return FALSE;
	}

	function get_current_revision ()
	{
		// This is done using SVN
		$REVISION_STRING = "$LastChangedRevision$";
		preg_match ("/: (\d+)/", $REVISION_STRING, $matched);
		return $matched[1];
	}

?>
